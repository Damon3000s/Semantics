<!-- Generated by SpecStory -->

# Next steps for domain implementation (2025-06-13 09:49:18)

_**User**_

@IMPLEMENTATION_SUMMARY.md @TODO_DOMAINS.md continue

---

_**Assistant**_

Here’s a summary and continuation plan based on the content of both `IMPLEMENTATION_SUMMARY.md` and `TODO_DOMAINS.md`:

---

## Current Status

- **Chemical Domain**: Fully implemented, production-ready, with all physical constants centralized and type-safe access via `PhysicalConstants.Generic`. 376/376 tests passing.
- **Core Infrastructure**: Complete. Includes robust base classes, unit system, and bootstrap for circular dependency resolution.
- **Documentation & Testing**: Comprehensive XML docs, implementation notes, and mathematical verification for all constants and relationships.

---

## Next Steps (as recommended in both docs)

### 1. Mechanical Domain (Highest Priority)
- **Why**: It’s foundational for other domains (e.g., force, energy, pressure, power).
- **How**: 
  - Use the Chemical domain as a template.
  - Before coding, search for any hard-coded constants (e.g., gravitational acceleration, atmospheric pressure) and add them to `PhysicalConstants.cs`.
  - Implement quantities like Force, Energy, Power, Pressure, etc., with full unit conversions and dimensional analysis.
  - Add comprehensive unit tests, including mathematical relationship checks (e.g., F = m·a, P = F/A, E = F·d).
  - Document all new quantities and constants.

### 2. Integration Tests
- **Why**: To ensure cross-domain relationships (e.g., mechanical and chemical, mechanical and thermal).
- **How**: 
  - Create tests that use quantities from multiple domains in calculations.
  - Verify that units and conversions work seamlessly across domains.

### 3. Performance Benchmarks
- **Why**: To compare the efficiency of using centralized constants vs. hard-coded values.
- **How**: 
  - Add benchmarks for common operations (e.g., unit conversions, arithmetic).
  - Optimize as needed.

### 4. Documentation Expansion
- **Why**: To maintain clarity as the library grows.
- **How**: 
  - Update the `docs/complete-library-guide.md` with new domains and features.
  - Add usage examples for new quantities.
  - Ensure all references in `README.md` and other docs are accurate (e.g., `docs/examples/`).

---

## Medium-Term Roadmap

1. **Electromagnetic Domain**: After Mechanical, implement quantities like ElectricCurrent, Voltage, Resistance, etc. Add relevant constants (elementary charge, magnetic permeability).
2. **Thermal Domain**: Integrate with Chemical and Mechanical. Implement Temperature, HeatCapacity, etc., and add constants like the Stefan-Boltzmann constant.
3. **Optical, Acoustic, Nuclear, Fluid Dynamics Domains**: Follow the same pattern—constants first, then quantities, then tests and documentation.

---

## Implementation Guidelines (from both docs)

- **Always centralize physical constants** in `PhysicalConstants.cs` before using them in any domain.
- **Use type-safe generic accessors** for all constants.
- **Refactor any hard-coded values** found in new or existing code.
- **Document all sources** for constants (CODATA, NIST, ISO/IEC).
- **Follow the established code and documentation standards** (file headers, XML docs, null safety, generic constraints).
- **Test thoroughly**: unit tests, mathematical verification, integration tests.

---

## Immediate Action Items

- Begin implementation of the Mechanical domain:
  - Search for and define all required physical constants.
  - Implement core mechanical quantities and their units.
  - Add and verify unit tests.
  - Update documentation and examples.

- Prepare for integration and performance testing as new domains are added.

---

**Summary:**  
The Chemical domain is complete and sets the standard for future work. The next step is to implement the Mechanical domain, following the established process: constants first, then quantities, then tests and documentation. Continue expanding to other domains, always centralizing constants and maintaining high code and documentation quality.

If you want to start with a specific mechanical quantity or need a template for a new domain, let me know!

---

_**User**_

yes please continue

---

_**Assistant**_

Great! Here’s a concrete, actionable continuation plan for the Semantics library, following the established process and the recommendations from your documentation.

---

## 1. Mechanical Domain Implementation Plan

### a. **Physical Constants First**
- **Action:** Identify all mechanical constants needed (e.g., gravitational acceleration, standard atmospheric pressure, Planck’s constant if needed for mechanics, etc.).
- **Where:** Add them to `PhysicalConstants.cs` under appropriate categories (Fundamental, Mechanical, etc.).
- **How:** Use the `PhysicalConstants.Generic` pattern for type-safe access.
- **Documentation:** Include XML docs and source references (CODATA, NIST, etc.).

### b. **Define Quantities**
- **Location:** `Quantities/Mechanics/`
- **Quantities to Implement:**
  - Force (`Force.cs`)
  - Pressure (`Pressure.cs`)
  - Energy (`Energy.cs`)
  - Power (`Power.cs`)
  - Torque (`Torque.cs`)
  - Momentum (`Momentum.cs`)
  - AngularVelocity (`AngularVelocity.cs`)
  - AngularAcceleration (`AngularAcceleration.cs`)
  - MomentOfInertia (`MomentOfInertia.cs`)
  - Density (`Density.cs`)
  - SpecificGravity (`SpecificGravity.cs`)
  - (And any others listed in your TODOs)
- **Pattern:** Follow the template from the Chemical domain (generic, type-safe, XML docs, unit conversions, etc.).

### c. **Units and Dimensions**
- **Action:** For each quantity, define the SI and common units in `Units.cs`.
- **Dimensions:** Add or update `PhysicalDimensions.cs` as needed for new dimensions (e.g., force, energy).

### d. **Mathematical Relationships**
- **Action:** Implement relationships (e.g., F = m·a, P = F/A, E = F·d) as static methods or extension methods.
- **Testing:** Add unit tests to verify these relationships using both constants and calculated values.

### e. **Testing**
- **Action:** For each quantity:
  - Create unit tests for creation, conversion, and validation.
  - Add mathematical verification tests (e.g., compare calculated force to expected value).
  - Add edge case and error handling tests.

### f. **Documentation**
- **Action:** Update or create:
  - XML docs for all new types and members.
  - `docs/complete-library-guide.md` with new mechanical quantities and usage examples.
  - `README.md` and any references to examples (ensure they point to `docs/examples/`).

---

## 2. Integration and Performance

- **Integration Tests:** Create tests that use both chemical and mechanical quantities together (e.g., energy calculations involving moles and force).
- **Performance Benchmarks:** Add benchmarks for common operations (unit conversions, arithmetic, etc.).

---

## 3. Review and Refactor

- **Refactor:** As you implement, refactor any hard-coded values found in other domains to use the new constants.
- **Review:** Ensure all code follows the standards (headers, null safety, XML docs, etc.).

---

## 4. Next Domains

- **After Mechanical:** Move to Electromagnetic, then Thermal, then Optical, Acoustic, Nuclear, and Fluid Dynamics, following the same process.

---

## 5. Example: Force Quantity Skeleton

Here’s a quick template for what a new quantity (e.g., Force) might look like, following your standards:

```csharp
// Copyright (c) KTSU. All rights reserved.

using System;
using System.Numerics;

namespace ktsu.Semantics.Quantities.Mechanics
{
    /// <summary>
    /// Represents a physical quantity of force.
    /// </summary>
    /// <remarks>
    /// SI unit: Newton (N)
    /// </remarks>
    public sealed class Force<T> : PhysicalQuantity<Force<T>, T>
        where T : struct, INumber<T>
    {
        /// <inheritdoc/>
        public override PhysicalDimension Dimension => PhysicalDimensions.Force;

        public Force() : base() { }

        // Static factory, conversions, etc.

        // Example: F = m * a
        public static Force<T> FromMassAndAcceleration(Mass<T> mass, Acceleration<T> acceleration)
            => new Force<T>(mass.Value * acceleration.Value);

        // ... other methods, conversions, XML docs
    }
}
```

---

## 6. Ready to Start?

If you want, I can:
- Generate the list of required mechanical constants and their definitions for `PhysicalConstants.cs`.
- Scaffold the first mechanical quantity (e.g., `Force<T>`).
- Provide a checklist for the next steps.

**Let me know which part you’d like to start with, or if you want a full code scaffold for the Mechanical domain!**

---

_**User**_

replace the todo domains and implementation summary documents with a full implementation plan and tracker document

---

_**Assistant**_



---



---

The unified implementation plan and tracker was intended to replace both `TODO_DOMAINS.md` and `IMPLEMENTATION_SUMMARY.md`. However, it appears the files were not updated as expected.

Here’s what should be in place:

- `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
- `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.

**If you’d like, I can try again to ensure these files are updated as described, or provide the full content for you to copy-paste. Let me know how you’d like to proceed!**

---

_**User**_

yeah do a check and then begin implementation

---

_**Assistant**_

Read file: Semantics/TODO_DOMAINS.md

---

Read file: Semantics/IMPLEMENTATION_SUMMARY.md

---

<details>
            <summary>Searched codebase "PhysicalConstants.cs" • **2** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |

</details>

---

Read file: Semantics/Quantities/Core/PhysicalConstants.cs

---

**Check complete:**  
- `TODO_DOMAINS.md` is now a unified, actionable implementation plan and tracker.
- `IMPLEMENTATION_SUMMARY.md` correctly points to `TODO_DOMAINS.md`.
- `PhysicalConstants.cs` already contains a section for mechanical constants (e.g., StandardGravity, StandardAtmosphericPressure) and generic accessors.

---

## Begin Implementation: Mechanical Domain

### Step 1: List and Define Required Mechanical Constants

**Already present:**
- Standard gravitational acceleration (`StandardGravity`)
- Standard atmospheric pressure (`StandardAtmosphericPressure`)
- Pound mass to kilogram (`PoundMassToKilogram`)

**To consider adding (if not present):**
- Joule definition (energy unit, but likely handled in units)
- Newton definition (force unit, but likely handled in units)
- Any other mechanical conversion factors (e.g., erg, dyne, etc.)

### Step 2: Scaffold and Implement Quant

---

