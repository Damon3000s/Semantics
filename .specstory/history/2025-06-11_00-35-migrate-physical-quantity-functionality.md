<!-- Generated by SpecStory -->

# Migrate physical quantity functionality (2025-06-11 10:35:47)

_**User**_

I want to migrate the physical quantity functionality into the semantics library

---

_**Assistant**_



---

I'll help you migrate the physical quantity functionality into the semantics library. Let me first explore the current workspace structure to understand what we're working with.

---

<details>
            <summary>Listed current directory • **35** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `VERSION.md` |
| 📄 `CHANGELOG.md` |
| 📄 `README.md` |
| 📄 `DESCRIPTION.md` |
| 📁 `docs` |
| 📁 `Semantics.Test` |
| 📄 `Directory.Packages.props` |
| 📁 `Semantics` |
| 📁 `TestResults` |
| 📁 `obj` |
| 📁 `bin` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.md` |
| 📁 `.sonarlint` |
| 📁 `.vscode` |
| 📄 `TAGS.md` |
| 📁 `.specstory` |
| 📄 `.cursorignore` |
| 📁 `.cursor` |
| 📁 `.vs` |
| 📄 `.gitignore` |
| 📄 `LICENSE.md` |
| 📄 `PROJECT_URL.url` |
| 📄 `Semantics.sln` |
| 📁 `scripts` |
| 📁 `.github` |
| 📄 `.cursorindexingignore` |
| 📄 `.runsettings` |
| 📄 `.editorconfig` |
| 📄 `global.json` |
| 📄 `.mailmap` |
| 📄 `.gitattributes` |
| 📄 `AUTHORS.url` |
| 📄 `icon.png` |

</details>

---



---

<details>
            <summary>Listed directory Semantics • **35** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `VERSION.md` |
| 📄 `CHANGELOG.md` |
| 📄 `README.md` |
| 📄 `DESCRIPTION.md` |
| 📁 `docs` |
| 📁 `Semantics.Test` |
| 📄 `Directory.Packages.props` |
| 📁 `Semantics` |
| 📁 `TestResults` |
| 📁 `obj` |
| 📁 `bin` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.md` |
| 📁 `.sonarlint` |
| 📁 `.vscode` |
| 📄 `TAGS.md` |
| 📁 `.specstory` |
| 📄 `.cursorignore` |
| 📁 `.cursor` |
| 📁 `.vs` |
| 📄 `.gitignore` |
| 📄 `LICENSE.md` |
| 📄 `PROJECT_URL.url` |
| 📄 `Semantics.sln` |
| 📁 `scripts` |
| 📁 `.github` |
| 📄 `.cursorindexingignore` |
| 📄 `.runsettings` |
| 📄 `.editorconfig` |
| 📄 `global.json` |
| 📄 `.mailmap` |
| 📄 `.gitattributes` |
| 📄 `AUTHORS.url` |
| 📄 `icon.png` |

</details>

---



---

<details>
            <summary>Listed directory Semantics • **35** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `VERSION.md` |
| 📄 `CHANGELOG.md` |
| 📄 `README.md` |
| 📄 `DESCRIPTION.md` |
| 📁 `docs` |
| 📁 `Semantics.Test` |
| 📄 `Directory.Packages.props` |
| 📁 `Semantics` |
| 📁 `TestResults` |
| 📁 `obj` |
| 📁 `bin` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.md` |
| 📁 `.sonarlint` |
| 📁 `.vscode` |
| 📄 `TAGS.md` |
| 📁 `.specstory` |
| 📄 `.cursorignore` |
| 📁 `.cursor` |
| 📁 `.vs` |
| 📄 `.gitignore` |
| 📄 `LICENSE.md` |
| 📄 `PROJECT_URL.url` |
| 📄 `Semantics.sln` |
| 📁 `scripts` |
| 📁 `.github` |
| 📄 `.cursorindexingignore` |
| 📄 `.runsettings` |
| 📄 `.editorconfig` |
| 📄 `global.json` |
| 📄 `.mailmap` |
| 📄 `.gitattributes` |
| 📄 `AUTHORS.url` |
| 📄 `icon.png` |

</details>

---



---

Read file: Semantics.sln

---



---

```bash
dir Semantics
```

```
C:\dev\ktsu-dev\Semantics>dir Semantics
 Volume in drive C is Windows 
10/06/2025  10:35 PM    <DIR>          .Semantics
11/06/2025  10:45 AM    <DIR>          ..
10/06/2025  07:30 PM    <DIR>          bin
11/06/2025  10:44 AM    <DIR>          obj
10/06/2025  09:32 PM    <DIR>          Paths
10/06/2025  09:32 PM    <DIR>          Quantities
10/06/2025  10:54 PM               129 Semantics.csproj
10/06/2025  10:08 PM    <DIR>          Strings
10/06/2025  08:56 PM    <DIR>          Utilities
10/06/2025  11:14 PM    <DIR>          Validation
               1 File(s)            129 bytes
Microsoft Windows [Version 10.0.26100.4061]
(c) Microsoft Corporation. All rights reserved.

C:\dev\ktsu-dev\Semantics>dir Semantics
 Volume in drive C is Windows
 Volume Serial Number is 32E3-1816

 Directory of C:\dev\ktsu-dev\Semantics\Semantics

10/06/2025  10:35 PM    <DIR>          .
11/06/2025  10:45 AM    <DIR>          ..
10/06/2025  07:30 PM    <DIR>          bin
11/06/2025  10:44 AM    <DIR>          obj
10/06/2025  09:32 PM    <DIR>          Paths
10/06/2025  09:32 PM    <DIR>          Quantities
10/06/2025  10:54 PM               129 Semantics.csproj
10/06/2025  10:08 PM    <DIR>          Strings
10/06/2025  08:56 PM    <DIR>          Utilities
10/06/2025  11:14 PM    <DIR>          Validation
               1 File(s)            129 bytes
               9 Dir(s)  698,568,167,424 bytes free

C:\dev\ktsu-dev\Semantics>






C:\dev\ktsu-dev\Semantics>
```

---



---

Perfect! I can see the Semantics library already has a structure with a `Quantities` directory. Let me explore what's currently in the Quantities directory to understand the existing physical quantity functionality.

---

Could not resolve URI: Error: Unable to resolve nonexistent file 'c:\dev\ktsu-dev\Semantics\Quantities'

---



---

```bash
dir Semantics\Quantities
```

```
C:\dev\ktsu-dev\Semantics>dir Semantics\Quantities
 Volume in drive C is Windows 
10/06/2025  09:32 PM    <DIR>          .Semantics\Quantities
10/06/2025  10:35 PM    <DIR>          ..
08/06/2025  02:55 AM             8,543 SemanticQuantity.cs
               1 File(s)          8,543 bytes
C:\dev\ktsu-dev\Semantics>
```

---



---

Could not find file 'Semantics/Quantities/SemanticQuantity.cs' in the workspace.

---



---

Read file: Semantics/Semantics/Quantities/SemanticQuantity.cs

---



---

Great! I can see there's already a solid foundation for semantic quantities in the library. The `SemanticQuantity<TStorage>` and `SemanticQuantity<TSelf, TStorage>` classes provide excellent infrastructure for physical quantities.

Let me search for any existing physical quantity implementations or related functionality that might need to be migrated.

---

<details>
            <summary>Searched codebase "physical quantity units measurement" • **0** results</summary>
        
No results found
</details>

---



---

<details>
            <summary>Searched codebase "Length Area Volume Mass Time Temperature Force" • **0** results</summary>
        
No results found
</details>

---



---

<details>
            <summary>Listed directory Semantics.Test • **16** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SemanticStringExtensionsTests.cs` |
| 📄 `UtilityTests.cs` |
| 📄 `FluentValidationAdapterTests.cs` |
| 📄 `SemanticPathTests.cs` |
| 📄 `SemanticPathInterfaceTests.cs` |
| 📄 `ErrorHandlingTests.cs` |
| 📄 `SemanticStringTests.cs` |
| 📄 `ValidationStrategyTests.cs` |
| 📄 `SemanticQuantityTests.cs` |
| 📄 `PathValidationAttributeTests.cs` |
| 📄 `AdvancedAttributeValidationTests.cs` |
| 📄 `SemanticStringFactoryTests.cs` |
| 📄 `AttributeValidationTests.cs` |
| 📁 `bin` |
| 📄 `Semantics.Test.csproj` |

</details>

---



---

Read file: Semantics.Test/SemanticQuantityTests.cs

---



---

Perfect! I can see the current state of the physical quantity system in the Semantics library. There's already a solid foundation with:

1. **Base semantic quantity classes** that support arithmetic operations
2. **Type-safe operations** with proper generic constraints
3. **Test examples** showing `Distance`, `Time`, and `Speed` quantities

However, the current implementation only has test types. To properly migrate physical quantity functionality, I need to understand what specific physical quantities and units you want to implement.

Let me search for any existing physical quantity implementations or documentation about what needs to be migrated:

---

<details>
            <summary>Searched web "ktsu-dev physical quantity library units measurement" • **6** results</summary>
        
| Title | URL |
|-------|-----|
| mpusz/mp-units: The quantities and units library for C++ | https://github.com/mpusz/mp-units |
| PhpUnitsOfMeasure/php-units-of-measure | https://github.com/PhpUnitsOfMeasure/php-units-of-measure |
| Quantities and units library | https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r0.html |
| GitHub - alonkashtan/k-unit-converter: A cross language unit conversion library | https://github.com/alonkashtan/k-unit-converter |
| GitHub - kwikius/pqs: C++ Physical Quantities System | https://github.com/kwikius/pqs |
| GitHub - buge/ts-units: Physical Units for TypeScript | https://github.com/buge/ts-units |

</details>

---



---

Now I need to understand what existing physical quantity functionality you want to migrate. Let me search for any related projects or implementations that might contain the physical quantities you want to move.

---

<details>
            <summary>Searched codebase "ktsu-dev physical quantity projects repositories" • **0** results</summary>
        
No results found
</details>

---



---

<details>
            <summary>Grep search for "Physical.*[Qq]uantit" • **15** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/SIUnitAttributeTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/SIUnitAttributeTests.cs` | L2 | `using ktsu.PhysicalQuantity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityTests.cs` | Lundefined | `namespace ktsu.PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityTests.cs` | L2 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityTests.cs` | L8 | `public class PhysicalQuantityTests` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityTests.cs` | L10 | `public record TestQuantity : PhysicalQuantity<TestQuantity> { }` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L2 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L3 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L4 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L5 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L6 | `using ktsu.PhysicalQuantity.Mass;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L7 | `using ktsu.PhysicalQuantity.Force;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L8 | `using ktsu.PhysicalQuantity.Energy;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L9 | `using ktsu.PhysicalQuantity.Power;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L10 | `using ktsu.PhysicalQuantity.Area;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L11 | `using ktsu.PhysicalQuantity.Volume;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L12 | `using ktsu.PhysicalQuantity.Density;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L13 | `using ktsu.PhysicalQuantity.Pressure;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L14 | `using ktsu.PhysicalQuantity.Momentum;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L15 | `using ktsu.PhysicalQuantity.ElectricCurrent;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L16 | `using ktsu.PhysicalQuantity.ElectricPotential;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L17 | `using ktsu.PhysicalQuantity.Resistance;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityOperationsTests.cs` | L21 | `public class PhysicalQuantityOperationsTests` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L2 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L3 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L4 | `using ktsu.PhysicalQuantity.Mass;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L5 | `using ktsu.PhysicalQuantity.Temperature;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L6 | `using ktsu.PhysicalQuantity.Area;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L7 | `using ktsu.PhysicalQuantity.Volume;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L8 | `using ktsu.PhysicalQuantity.Angle;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L9 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L10 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L11 | `using ktsu.PhysicalQuantity.Energy;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L12 | `using ktsu.PhysicalQuantity.Force;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L13 | `using ktsu.PhysicalQuantity.Power;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityExtensionMethodTests.cs` | L18 | `public class PhysicalQuantityExtensionMethodTests` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityEdgeCaseTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityEdgeCaseTests.cs` | L2 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityEdgeCaseTests.cs` | L10 | `public class PhysicalQuantityEdgeCaseTests` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityEdgeCaseTests.cs` | L12 | `public record TestQuantity : PhysicalQuantity<TestQuantity> { }` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L2 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L3 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L4 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L5 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L6 | `using ktsu.PhysicalQuantity.Mass;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L7 | `using ktsu.PhysicalQuantity.Force;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L8 | `using ktsu.PhysicalQuantity.Energy;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L9 | `using ktsu.PhysicalQuantity.Power;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L10 | `using ktsu.PhysicalQuantity.Area;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L11 | `using ktsu.PhysicalQuantity.Volume;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L12 | `using ktsu.PhysicalQuantity.Density;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L13 | `using ktsu.PhysicalQuantity.Temperature;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/PhysicalQuantityConversionTests.cs` | L18 | `public class PhysicalQuantityConversionTests` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IIntegralOperatorsTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IIntegralOperatorsTests.cs` | L2 | `using ktsu.PhysicalQuantity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IIntegralOperatorsTests.cs` | L3 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IIntegralOperatorsTests.cs` | L10 | `public record MockQuantity : PhysicalQuantity<MockQuantity>, IIntegralOperators<MockQuantity, MockQuantity, MockQuantity>` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IDerivativeOperatorsTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IDerivativeOperatorsTests.cs` | L2 | `using ktsu.PhysicalQuantity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IDerivativeOperatorsTests.cs` | L3 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/IDerivativeOperatorsTests.cs` | L10 | `public record MockQuantity : PhysicalQuantity<MockQuantity>, IDerivativeOperators<MockQuantity, MockQuantity, MockQuantity>` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/ConstantsTests.cs` | Lundefined | `namespace PhysicalQuantity.Tests;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/Test/ConstantsTests.cs` | L2 | `using ktsu.PhysicalQuantity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | Lundefined | `# ktsu.PhysicalQuantity` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L2 | ``PhysicalQuantity` is a .NET library that provides a robust framework for working with physical quantities, supporting a wide range of units and conversions.` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L6 | `- **Comprehensive Unit Support**: Supports a wide range of physical quantities including length, mass, time, energy, and more.` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L13 | `To install PhysicalQuantity, run the following command in your .NET project:` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L16 | `dotnet add package ktsu.PhysicalQuantity` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L24 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L64 | `using ktsu.PhysicalQuantity.Mass;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L75 | `The `PhysicalQuantity` library supports operations for integrating and deriving physical quantities, making it easier to work with quantities that result from these operations.` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L82 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L83 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L84 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L99 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L100 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L101 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L116 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L117 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L118 | `using ktsu.PhysicalQuantity.Time;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/README.md` | L119 | `using ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PROJECT_URL.url` | L1 | `URL=https://github.com/ktsu-dev/PhysicalQuantity` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity.sln` | L5 | `Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "PhysicalQuantity", "PhysicalQuantity\PhysicalQuantity.csproj", "{D83F509D-D4A6-406F-AEB2-5DAC1E3456CA}"` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity.sln` | L7 | `Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PhysicalQuantity.Test", "Test\PhysicalQuantity.Test.csproj", "{798FF963-CD6F-4A38-88F9-6027E394818E}"` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/SIUnitAttribute.cs` | L4 | `namespace ktsu.PhysicalQuantity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/SIUnitAttribute.cs` | L10 | `/// This attribute is intended to be applied to classes that represent physical quantities` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L4 | `namespace ktsu.PhysicalQuantity.Volume;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L8 | `using ktsu.PhysicalQuantity.Area;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L9 | `using ktsu.PhysicalQuantity.Density;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L10 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L11 | `using ktsu.PhysicalQuantity.Length;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L12 | `using ktsu.PhysicalQuantity.Mass;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Volume.cs` | L21 | `: PhysicalQuantity<Volume>` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Velocity.cs` | L4 | `namespace ktsu.PhysicalQuantity.Velocity;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Velocity.cs` | L8 | `using ktsu.PhysicalQuantity.Acceleration;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Velocity.cs` | L9 | `using ktsu.PhysicalQuantity.Generic;` |
| `file:///c%3A/dev/ktsu-dev/PhysicalQuantity/PhysicalQuantity/Quantities/Velocity.cs` | L10 | `using ktsu.PhysicalQuantity.Length;` |

</details>

---

_**User**_

I added the physical quantity repo to this workspace so that you can copy its functionality

---

_**Assistant**_



---

Perfect! I can see you've added the PhysicalQuantity repository to the workspace. Let me explore the structure of the existing PhysicalQuantity library to understand what functionality needs to be migrated into the Semantics library.

---

<details>
            <summary>Listed directory ../PhysicalQuantity • **25** results</summary>
        
| Name |
|-------|
| 📄 `Directory.Packages.props` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.md` |
| 📄 `.gitignore` |
| 📄 `.runsettings` |
| 📄 `.editorconfig` |
| 📄 `global.json` |
| 📁 `.git` |
| 📁 `Test` |
| 📁 `PhysicalQuantity` |
| 📄 `CHANGELOG.md` |
| 📄 `PROJECT_URL.url` |
| 📄 `LICENSE.md` |
| 📄 `.mailmap` |
| 📄 `.gitattributes` |
| 📄 `AUTHORS.url` |
| 📁 `scripts` |
| 📄 `VERSION.md` |
| 📁 `TestResults` |
| 📄 `icon.png` |
| 📄 `PhysicalQuantity.sln` |
| 📁 `.vs` |
| 📄 `README.md` |
| 📄 `DESCRIPTION.md` |
| 📁 `.github` |

</details>

---



---

<details>
            <summary>Listed directory ../PhysicalQuantity/PhysicalQuantity • **9** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `PhysicalQuantity.csproj` |
| 📄 `SIUnitAttribute.cs` |
| 📄 `PhysicalQuantity.cs` |
| 📄 `IDerivativeOperators.cs` |
| 📄 `IIntegralOperators.cs` |
| 📄 `Constants.cs` |
| 📁 `Quantities` |
| 📁 `bin` |

</details>

---



---

<details>
            <summary>Listed directory ../PhysicalQuantity/PhysicalQuantity/Quantities • **31** results</summary>
        
| Name |
|-------|
| 📄 `Torque.cs` |
| 📄 `Velocity.cs` |
| 📄 `Volume.cs` |
| 📄 `Time.cs` |
| 📄 `Temperature.cs` |
| 📄 `Resistance.cs` |
| 📄 `SolidAngle.cs` |
| 📄 `Power.cs` |
| 📄 `Pressure.cs` |
| 📄 `Momentum.cs` |
| 📄 `MolarMass.cs` |
| 📄 `MomentOfInertia.cs` |
| 📄 `Mass.cs` |
| 📄 `LuminousFlux.cs` |
| 📄 `LuminousIntensity.cs` |
| 📄 `Jerk.cs` |
| 📄 `Length.cs` |
| 📄 `Illuminance.cs` |
| 📄 `Energy.cs` |
| 📄 `Force.cs` |
| 📄 `ElectricCurrent.cs` |
| 📄 `ElectricPotential.cs` |
| 📄 `Density.cs` |
| 📄 `Area.cs` |
| 📄 `Charge.cs` |
| 📄 `AngularVelocity.cs` |
| 📄 `AngularMomentum.cs` |
| 📄 `Angle.cs` |
| 📄 `AngularAcceleration.cs` |
| 📄 `Acceleration.cs` |
| 📄 `AmountOfSubstance.cs` |

</details>

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/PhysicalQuantity.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/SIUnitAttribute.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/Quantities/Length.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/Constants.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/Quantities/Velocity.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/IIntegralOperators.cs

---



---

Read file: ../PhysicalQuantity/PhysicalQuantity/IDerivativeOperators.cs

---



---

Excellent! I can see the comprehensive PhysicalQuantity library that needs to be migrated. Based on my analysis, I'll create a migration plan and start implementing it.

## Migration Overview

The PhysicalQuantity library has:
- 31+ physical quantity types (Length, Mass, Time, Energy, Velocity, etc.)
- A sophisticated base class `PhysicalQuantity<TSelf>` that extends `SemanticQuantity<TSelf, StorageType>`
- SI unit attributes for metadata (symbol, singular/plural names)
- Extension methods for unit conversions
- Integral and derivative operator interfaces for physical relationships
- Comprehensive conversion constants

Let me start migrating this functionality into the Semantics library:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics;
+ 
+ /// <summary>
+ /// An attribute to define the SI unit for a class.
+ /// </summary>
+ /// <remarks>
+ /// This attribute is intended to be applied to classes that represent physical quantities
+ /// and their associated SI units.
+ /// </remarks>
+ [AttributeUsage(AttributeTargets.Class)]
+ public sealed class SIUnitAttribute(string symbol, string singular, string plural) : Attribute
+ {
+ 	/// <summary>
+ 	/// Gets the symbol of the SI unit (e.g., "m" for meters).
+ 	/// </summary>
+ 	public string Symbol { get; } = symbol;
+ 
+ 	/// <summary>
+ 	/// Gets the singular name of the SI unit (e.g., "meter").
+ 	/// </summary>
+ 	public string Singular { get; } = singular;
+ 
+ 	/// <summary>
+ 	/// Gets the plural name of the SI unit (e.g., "meters").
+ 	/// </summary>
+ 	public string Plural { get; } = plural;
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Defines an interface for integral operations between physical quantities.
+ /// </summary>
+ /// <typeparam name="TSelf">
+ /// The type of the left operand, which must inherit from <see cref="PhysicalQuantity{TSelf}"/> 
+ /// and implement <see cref="IIntegralOperators{TSelf, TOther, TResult}"/>.
+ /// </typeparam>
+ /// <typeparam name="TOther">
+ /// The type of the right operand, which must inherit from <see cref="PhysicalQuantity{TOther}"/>.
+ /// </typeparam>
+ /// <typeparam name="TResult">
+ /// The type of the result, which must inherit from <see cref="PhysicalQuantity{TResult}"/>.
+ /// </typeparam>
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1005:Avoid excessive parameters on generic types", Justification = "Required for type-safe physical quantity operations")]
+ public interface IIntegralOperators<TSelf, TOther, TResult>
+ 	: IMultiplyOperators<TSelf, TOther, TResult>
+ 	where TSelf : PhysicalQuantity<TSelf>, IIntegralOperators<TSelf, TOther, TResult>, new()
+ 	where TOther : PhysicalQuantity<TOther>, new()
+ 	where TResult : PhysicalQuantity<TResult>, new()
+ {
+ 	/// <summary>
+ 	/// Performs an integration operation between two physical quantities.
+ 	/// </summary>
+ 	/// <param name="left">The left operand of type <typeparamref name="TSelf"/>.</param>
+ 	/// <param name="right">The right operand of type <typeparamref name="TOther"/>.</param>
+ 	/// <returns>
+ 	/// A new instance of <typeparamref name="TResult"/> representing the result of the integration.
+ 	/// </returns>
+ 	public static TResult Integrate(TSelf left, TOther right) =>
+ 		PhysicalQuantity<TSelf>.Multiply<TResult>(left, right);
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Defines an interface for derivative operations between physical quantities.
+ /// </summary>
+ /// <typeparam name="TSelf">
+ /// The type of the left operand, which must inherit from <see cref="PhysicalQuantity{TSelf}"/> 
+ /// and implement <see cref="IDerivativeOperators{TSelf, TOther, TResult}"/>.
+ /// </typeparam>
+ /// <typeparam name="TOther">
+ /// The type of the right operand, which must inherit from <see cref="PhysicalQuantity{TOther}"/>.
+ /// </typeparam>
+ /// <typeparam name="TResult">
+ /// The type of the result, which must inherit from <see cref="PhysicalQuantity{TResult}"/>.
+ /// </typeparam>
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1005:Avoid excessive parameters on generic types", Justification = "Required for type-safe physical quantity operations")]
+ public interface IDerivativeOperators<TSelf, TOther, TResult>
+ 	: IDivisionOperators<TSelf, TOther, TResult>
+ 	where TSelf : PhysicalQuantity<TSelf>, IDerivativeOperators<TSelf, TOther, TResult>, new()
+ 	where TOther : PhysicalQuantity<TOther>, new()
+ 	where TResult : PhysicalQuantity<TResult>, new()
+ {
+ 	/// <summary>
+ 	/// Computes the derivative of two physical quantities.
+ 	/// </summary>
+ 	/// <param name="left">The left operand of type <typeparamref name="TSelf"/>.</param>
+ 	/// <param name="right">The right operand of type <typeparamref name="TOther"/>.</param>
+ 	/// <returns>
+ 	/// A new instance of <typeparamref name="TResult"/> representing the result of the derivative operation.
+ 	/// </returns>
+ 	public static TResult Derive(TSelf left, TOther right) =>
+ 		PhysicalQuantity<TSelf>.Divide<TResult>(left, right);
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics;
+ 
+ /// <summary>
+ /// Provides conversion factors for various physical quantities and metric prefixes.
+ /// </summary>
+ public static class PhysicalConstants
+ {
+ 	// Metric prefixes
+ 	public static double Deca { get; } = 1e1;
+ 	public static double Hecto { get; } = 1e2;
+ 	public static double Kilo { get; } = 1e3;
+ 	public static double Mega { get; } = 1e6;
+ 	public static double Giga { get; } = 1e9;
+ 	public static double Tera { get; } = 1e12;
+ 	public static double Peta { get; } = 1e15;
+ 	public static double Exa { get; } = 1e18;
+ 	public static double Zetta { get; } = 1e21;
+ 	public static double Yotta { get; } = 1e24;
+ 	public static double Deci { get; } = 1e-1;
+ 	public static double Centi { get; } = 1e-2;
+ 	public static double Milli { get; } = 1e-3;
+ 	public static double Micro { get; } = 1e-6;
+ 	public static double Nano { get; } = 1e-9;
+ 	public static double Pico { get; } = 1e-12;
+ 	public static double Femto { get; } = 1e-15;
+ 	public static double Atto { get; } = 1e-18;
+ 	public static double Zepto { get; } = 1e-21;
+ 	public static double Yocto { get; } = 1e-24;
+ 
+ 	// Length conversion factors
+ 	public static double FeetToMetersFactor { get; } = 0.3048;
+ 	public static double InchesToMetersFactor { get; } = 0.0254;
+ 	public static double YardsToMetersFactor { get; } = 0.9144;
+ 	public static double MilesToMetersFactor { get; } = 1609.344;
+ 	public static double NauticalMilesToMetersFactor { get; } = 1852;
+ 	public static double FathomsToMetersFactor { get; } = 1.8288;
+ 	public static double AstronomicalUnitsToMetersFactor { get; } = 1.495978707e11;
+ 	public static double LightYearsToMetersFactor { get; } = 9.4607304725808e15;
+ 	public static double ParsecsToMetersFactor { get; } = 3.08567758149137e16;
+ 
+ 	// Angular conversion factors
+ 	public static double DegreesToRadiansFactor { get; } = 0.01745329251994329576923690768489;
+ 	public static double GradiansToRadiansFactor { get; } = 0.0157079632679489661923132169164;
+ 	public static double MinutesToRadiansFactor { get; } = 0.00029088820866572159615394846141459;
+ 	public static double SecondsToRadiansFactor { get; } = 4.8481368110953599358991410235795e-6;
+ 	public static double RevolutionsToRadiansFactor { get; } = 6.283185307179586476925286766559;
+ 	public static double CyclesToRadiansFactor { get; } = 6.283185307179586476925286766559;
+ 	public static double TurnsToRadiansFactor { get; } = 6.283185307179586476925286766559;
+ 
+ 	// Mass conversion factors
+ 	public static double PoundsToKilogramsFactor { get; } = 0.45359237;
+ 	public static double OuncesToKilogramsFactor { get; } = 0.028349523125;
+ 	public static double StonesToKilogramsFactor { get; } = 6.35029318;
+ 	public static double ImperialTonsToKilogramsFactor { get; } = 1016.0469088;
+ 	public static double USTonsToKilogramsFactor { get; } = 907.18474;
+ 	public static double MetricTonsToKilogramsFactor { get; } = 1000;
+ 
+ 	// Force conversion factors
+ 	public static double PoundsForceToNewtonsFactor { get; } = 4.4482216152605;
+ 
+ 	// Energy conversion factors
+ 	public static double CaloriesToJoulesFactor { get; } = 4.184;
+ 	public static double BTUsToJoulesFactor { get; } = 1055.05585262;
+ 
+ 	// Power conversion factors
+ 	public static double HorsepowerToWattsFactor { get; } = 745.69987158227022;
+ 	public static double MetricHorsePowerToWattsFactor { get; } = 735.49875;
+ 
+ 	// Pressure conversion factors
+ 	public static double BarToPascalsFactor { get; } = 1e5;
+ 	public static double PsiToPascalsFactor { get; } = 6894.757293168361;
+ 	public static double AtmToPascalsFactor { get; } = 101325;
+ 	public static double TorrToPascalsFactor { get; } = 133.32236842105263;
+ 
+ 	// Temperature conversion factors
+ 	public static double CelsiusToKelvinFactor { get; } = 1;
+ 	public static double CelsiusToKelvinOffset { get; } = 273.15;
+ 	public static double FahrenheitToCelsiusFactor { get; } = 9.0 / 5.0;
+ 	public static double FahrenheitToCelsiusOffset { get; } = 32;
+ 
+ 	// Time conversion factors
+ 	public static double MinutesToSecondsFactor { get; } = 60;
+ 	public static double HoursToSecondsFactor { get; } = 3600;
+ 	public static double DaysToSecondsFactor { get; } = 86400;
+ 	public static double HoursToMinutesFactor { get; } = 60;
+ 	public static double DaysToMinutesFactor { get; } = 1440;
+ 	public static double DaysToHoursFactor { get; } = 24;
+ 	public static double YearsToSecondsFactor { get; } = 31556952;
+ 
+ 	// Torque conversion factors
+ 	public static double FootPoundsToNewtonMetersFactor { get; } = 1.3558179483314004;
+ 	public static double PoundInchesToNewtonMetersFactor { get; } = 0.1130057188312;
+ 
+ 	// Illuminance conversion factors
+ 	public static double FootCandleToLuxFactor { get; } = 10.763910416709722;
+ 
+ 	// Area conversion factors
+ 	public static double AcresToSquareMetersFactor { get; } = 4046.8564224;
+ 
+ 	// Solid Angle conversion factors
+ 	public static double SquareDegreesToSteradiansFactor { get; } = 3282.80635001;
+ 
+ 	// Charge conversion factors
+ 	public static double MilliampereHoursToCoulombsFactor { get; } = 3.6;
+ 	public static double AmpereHoursToCoulombsFactor { get; } = 3600;
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ [assembly: CLSCompliant(true)]
+ [assembly: System.Runtime.InteropServices.ComVisible(false)]
+ 
+ namespace ktsu.Semantics;
+ 
+ using System.Numerics;
+ using System.Reflection;
+ 
+ /// <summary>
+ /// Represents a physical quantity with a specific unit of measurement.
+ /// </summary>
+ /// <typeparam name="TSelf">The type of the derived class.</typeparam>
+ public abstract record PhysicalQuantity<TSelf>
+ 	: SemanticQuantity<TSelf, double>
+ 	, IComparable<TSelf>
+ 	where TSelf : PhysicalQuantity<TSelf>, new()
+ {
+ 	/// <summary>
+ 	/// Gets the SI unit attribute associated with the derived class.
+ 	/// </summary>
+ 	private static SIUnitAttribute SIUnitAttribute { get; } = typeof(TSelf).GetCustomAttribute<SIUnitAttribute>() ?? new SIUnitAttribute(string.Empty, string.Empty, string.Empty);
+ 
+ 	/// <summary>
+ 	/// Compares the current physical quantity to another instance of the same type.
+ 	/// </summary>
+ 	/// <param name="other">The other physical quantity to compare to.</param>
+ 	/// <returns>
+ 	/// A value less than zero if this instance is less than <paramref name="other"/>, 
+ 	/// zero if they are equal, or a value greater than zero if this instance is greater than <paramref name="other"/>.
+ 	/// </returns>
+ 	public int CompareTo(TSelf? other) => other is null ? 1 : Quantity.CompareTo(other.Quantity);
+ 
+ 	/// <summary>
+ 	/// Returns a string representation of the physical quantity, including its unit symbol and name.
+ 	/// </summary>
+ 	/// <returns>A string that represents the physical quantity.</returns>
+ 	public sealed override string ToString()
+ 	{
+ 		var symbolComponent = string.IsNullOrWhiteSpace(SIUnitAttribute.Symbol) ? string.Empty : $" {SIUnitAttribute.Symbol}";
+ 		var absQuantity = Math.Abs(Quantity);
+ 		var isPlural = absQuantity > 1;
+ 		var pluralComponent = isPlural ? SIUnitAttribute.Plural : SIUnitAttribute.Singular;
+ 		var nameComponent = string.IsNullOrWhiteSpace(pluralComponent) ? string.Empty : $" ({pluralComponent})";
+ 		return $"{Quantity}{symbolComponent}{nameComponent}";
+ 	}
+ 
+ 	/// <summary>
+ 	/// Determines whether one physical quantity is less than another.
+ 	/// </summary>
+ 	/// <param name="left">The first physical quantity.</param>
+ 	/// <param name="right">The second physical quantity.</param>
+ 	/// <returns>True if <paramref name="left"/> is less than <paramref name="right"/>; otherwise, false.</returns>
+ 	public static bool operator <(PhysicalQuantity<TSelf> left, TSelf right) =>
+ 		left is null ? right is not null : left.CompareTo(right) < 0;
+ 
+ 	/// <summary>
+ 	/// Determines whether one physical quantity is less than or equal to another.
+ 	/// </summary>
+ 	/// <param name="left">The first physical quantity.</param>
+ 	/// <param name="right">The second physical quantity.</param>
+ 	/// <returns>True if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise, false.</returns>
+ 	public static bool operator <=(PhysicalQuantity<TSelf> left, TSelf right) =>
+ 		left is null || left.CompareTo(right) <= 0;
+ 
+ 	/// <summary>
+ 	/// Determines whether one physical quantity is greater than another.
+ 	/// </summary>
+ 	/// <param name="left">The first physical quantity.</param>
+ 	/// <param name="right">The second physical quantity.</param>
+ 	/// <returns>True if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise, false.</returns>
+ 	public static bool operator >(PhysicalQuantity<TSelf> left, TSelf right) =>
+ 		left is not null && left.CompareTo(right) > 0;
+ 
+ 	/// <summary>
+ 	/// Determines whether one physical quantity is greater than or equal to another.
+ 	/// </summary>
+ 	/// <param name="left">The first physical quantity.</param>
+ 	/// <param name="right">The second physical quantity.</param>
+ 	/// <returns>True if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise, false.</returns>
+ 	public static bool operator >=(PhysicalQuantity<TSelf> left, TSelf right) =>
+ 		left is null ? right is null : left.CompareTo(right) >= 0;
+ 
+ 	/// <summary>
+ 	/// Raises the physical quantity to the specified power.
+ 	/// </summary>
+ 	/// <typeparam name="TPower">The type of the power value.</typeparam>
+ 	/// <param name="power">The power to raise the quantity to.</param>
+ 	/// <returns>A new instance of the physical quantity raised to the specified power.</returns>
+ 	/// <exception cref="ArgumentNullException">Thrown if <paramref name="power"/> is null.</exception>
+ 	public TSelf Pow<TPower>(TPower power)
+ 		where TPower : INumber<TPower>
+ 	{
+ 		ArgumentNullException.ThrowIfNull(power);
+ 		return Create(Math.Pow(Quantity, Convert.ToDouble(power)));
+ 	}
+ 
+ 	/// <summary>
+ 	/// Returns the absolute value of the physical quantity.
+ 	/// </summary>
+ 	/// <returns>A new instance of the physical quantity with an absolute value.</returns>
+ 	public TSelf Abs() => Create(Math.Abs(Quantity));
+ 
+ 	/// <summary>
+ 	/// Clamps the physical quantity to the specified minimum and maximum values.
+ 	/// </summary>
+ 	/// <typeparam name="T1">The type of the minimum value.</typeparam>
+ 	/// <typeparam name="T2">The type of the maximum value.</typeparam>
+ 	/// <param name="min">The minimum value.</param>
+ 	/// <param name="max">The maximum value.</param>
+ 	/// <returns>A new instance of the physical quantity clamped to the specified range.</returns>
+ 	public TSelf Clamp<T1, T2>(T1 min, T2 max)
+ 		where T1 : INumber<T1>
+ 		where T2 : INumber<T2>
+ 		=> Create(Math.Clamp(Quantity, Convert.ToDouble(min), Convert.ToDouble(max)));
+ 
+ 	/// <summary>
+ 	/// Adds a specified value to the physical quantity during a unit conversion.
+ 	/// </summary>
+ 	/// <param name="other">The value to add.</param>
+ 	/// <returns>A new instance of the physical quantity with the added value.</returns>
+ 	protected TSelf ConversionAdd(double other) => Create(Quantity + other);
+ }
+ 
+ /// <summary>
+ /// Provides static methods for converting values to and from physical quantities.
+ /// </summary>
+ public static class PhysicalQuantity
+ {
+ 	/// <summary>
+ 	/// Converts a numeric value to a specific physical quantity type with a given conversion factor and offset.
+ 	/// </summary>
+ 	/// <typeparam name="TInput">The type of the input numeric value.</typeparam>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert to.</typeparam>
+ 	/// <param name="value">The numeric value to convert.</param>
+ 	/// <param name="factor">The conversion factor to apply.</param>
+ 	/// <param name="offset">The conversion offset to apply.</param>
+ 	/// <returns>A new instance of the specified physical quantity type.</returns>
+ 	public static TQuantity ConvertToQuantity<TInput, TQuantity>(this TInput value, double factor, double offset)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 		where TInput : INumber<TInput>
+ 		=> PhysicalQuantity<TQuantity>.Create((Convert.ToDouble(value) * factor) + offset);
+ 
+ 	/// <summary>
+ 	/// Converts a numeric value to a specific physical quantity type with a given conversion factor.
+ 	/// </summary>
+ 	/// <typeparam name="TInput">The type of the input numeric value.</typeparam>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert to.</typeparam>
+ 	/// <param name="value">The numeric value to convert.</param>
+ 	/// <param name="factor">The conversion factor to apply.</param>
+ 	/// <returns>A new instance of the specified physical quantity type.</returns>
+ 	public static TQuantity ConvertToQuantity<TInput, TQuantity>(this TInput value, double factor)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 		where TInput : INumber<TInput>
+ 		=> PhysicalQuantity<TQuantity>.Create(Convert.ToDouble(value) * factor);
+ 
+ 	/// <summary>
+ 	/// Converts a numeric value to a specific physical quantity type without any conversion factor or offset.
+ 	/// </summary>
+ 	/// <typeparam name="TInput">The type of the input numeric value.</typeparam>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert to.</typeparam>
+ 	/// <param name="value">The numeric value to convert.</param>
+ 	/// <returns>A new instance of the specified physical quantity type.</returns>
+ 	public static TQuantity ConvertToQuantity<TInput, TQuantity>(this TInput value)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 		where TInput : INumber<TInput>
+ 		=> PhysicalQuantity<TQuantity>.Create(Convert.ToDouble(value));
+ 
+ 	/// <summary>
+ 	/// Converts a physical quantity to a numeric value with a given conversion factor and offset.
+ 	/// </summary>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert from.</typeparam>
+ 	/// <param name="value">The physical quantity to convert.</param>
+ 	/// <param name="factor">The conversion factor to apply.</param>
+ 	/// <param name="offset">The conversion offset to apply.</param>
+ 	/// <returns>The numeric value representing the converted physical quantity.</returns>
+ 	public static double ConvertToNumber<TQuantity>(this TQuantity value, double factor, double offset)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 	{
+ 		ArgumentNullException.ThrowIfNull(value);
+ 		return (value.Quantity - offset) / factor;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Converts a physical quantity to a numeric value with a given conversion factor.
+ 	/// </summary>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert from.</typeparam>
+ 	/// <param name="value">The physical quantity to convert.</param>
+ 	/// <param name="factor">The conversion factor to apply.</param>
+ 	/// <returns>The numeric value representing the converted physical quantity.</returns>
+ 	public static double ConvertToNumber<TQuantity>(this TQuantity value, double factor)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 	{
+ 		ArgumentNullException.ThrowIfNull(value);
+ 		return value.Quantity / factor;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Converts a physical quantity to a numeric value without any conversion factor or offset.
+ 	/// </summary>
+ 	/// <typeparam name="TQuantity">The type of the physical quantity to convert from.</typeparam>
+ 	/// <param name="value">The physical quantity to convert.</param>
+ 	/// <returns>The numeric value representing the converted physical quantity.</returns>
+ 	public static double ConvertToNumber<TQuantity>(this TQuantity value)
+ 		where TQuantity : PhysicalQuantity<TQuantity>, new()
+ 	{
+ 		ArgumentNullException.ThrowIfNull(value);
+ 		return value.Quantity;
+ 	}
+ } 
```

---



---

```bash
mkdir Semantics\Semantics\Quantities
```

```
C:\dev\ktsu-dev\Semantics>mkdir Semantics\Semantics\Quantities
C:\dev\ktsu-dev\Semantics>
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Quantities;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Represents a length physical quantity.
+ /// </summary>
+ [SIUnit("m", "meter", "meters")]
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CA2225:Operator overloads have named alternates", Justification = "Physical quantity operations")]
+ public sealed record Length
+ 	: PhysicalQuantity<Length>
+ {
+ 	/// <summary>
+ 	/// Multiplies two <see cref="Length"/> instances to compute an <see cref="Area"/>.
+ 	/// </summary>
+ 	/// <param name="left">The first <see cref="Length"/> operand.</param>
+ 	/// <param name="right">The second <see cref="Length"/> operand.</param>
+ 	/// <returns>An <see cref="Area"/> representing the product of the two lengths.</returns>
+ 	public static Area operator *(Length left, Length right) =>
+ 		Multiply<Area>(left, right);
+ }
+ 
+ /// <summary>
+ /// Provides extension methods for converting values to and from <see cref="Length"/>.
+ /// </summary>
+ public static class LengthConversions
+ {
+ 	/// <summary>
+ 	/// Converts a value to meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in meters.</returns>
+ 	public static Length Meters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>();
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in meters.</returns>
+ 	public static TNumber Meters<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber());
+ 
+ 	// Metric prefixes
+ 	/// <summary>
+ 	/// Converts a value to kilometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in kilometers.</returns>
+ 	public static Length Kilometers<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.Kilo);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in kilometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in kilometers.</returns>
+ 	public static TNumber Kilometers<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Kilo));
+ 
+ 	/// <summary>
+ 	/// Converts a value to centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in centimeters.</returns>
+ 	public static Length Centimeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.Centi);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in centimeters.</returns>
+ 	public static TNumber Centimeters<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Centi));
+ 
+ 	/// <summary>
+ 	/// Converts a value to millimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in millimeters.</returns>
+ 	public static Length Millimeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.Milli);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in millimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in millimeters.</returns>
+ 	public static TNumber Millimeters<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Milli));
+ 
+ 	/// <summary>
+ 	/// Converts a value to micrometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in micrometers.</returns>
+ 	public static Length Micrometers<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.Micro);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in micrometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in micrometers.</returns>
+ 	public static TNumber Micrometers<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Micro));
+ 
+ 	/// <summary>
+ 	/// Converts a value to nanometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in nanometers.</returns>
+ 	public static Length Nanometers<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.Nano);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in nanometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in nanometers.</returns>
+ 	public static TNumber Nanometers<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Nano));
+ 
+ 	// Imperial and other conversions
+ 	/// <summary>
+ 	/// Converts a value to feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in feet.</returns>
+ 	public static Length Feet<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.FeetToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in feet.</returns>
+ 	public static TNumber Feet<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.FeetToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in inches.</returns>
+ 	public static Length Inches<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.InchesToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in inches.</returns>
+ 	public static TNumber Inches<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.InchesToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to yards.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in yards.</returns>
+ 	public static Length Yards<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.YardsToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in yards.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in yards.</returns>
+ 	public static TNumber Yards<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.YardsToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to miles.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in miles.</returns>
+ 	public static Length Miles<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.MilesToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in miles.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in miles.</returns>
+ 	public static TNumber Miles<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.MilesToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to nautical miles.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in nautical miles.</returns>
+ 	public static Length NauticalMiles<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.NauticalMilesToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in nautical miles.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in nautical miles.</returns>
+ 	public static TNumber NauticalMiles<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.NauticalMilesToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to fathoms.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Length"/> representing the value in fathoms.</returns>
+ 	public static Length Fathoms<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Length>(PhysicalConstants.FathomsToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Length"/> to a numeric value in fathoms.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Length"/> to convert.</param>
+ 	/// <returns>The numeric value in fathoms.</returns>
+ 	public static TNumber Fathoms<TNumber>(this Length value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.FathomsToMetersFactor));
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Quantities;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Represents an area physical quantity.
+ /// </summary>
+ [SIUnit("m²", "square meter", "square meters")]
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CA2225:Operator overloads have named alternates", Justification = "Physical quantity operations")]
+ public sealed record Area
+ 	: PhysicalQuantity<Area>
+ {
+ 	/// <summary>
+ 	/// Multiplies an <see cref="Area"/> and a <see cref="Length"/> to compute a <see cref="Volume"/>.
+ 	/// </summary>
+ 	/// <param name="left">The <see cref="Area"/> operand.</param>
+ 	/// <param name="right">The <see cref="Length"/> operand.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the product of the area and length.</returns>
+ 	public static Volume operator *(Area left, Length right) =>
+ 		Multiply<Volume>(left, right);
+ }
+ 
+ /// <summary>
+ /// Provides extension methods for converting values to and from <see cref="Area"/>.
+ /// </summary>
+ public static class AreaConversions
+ {
+ 	/// <summary>
+ 	/// Converts a value to square meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square meters.</returns>
+ 	public static Area SquareMeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>();
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square meters.</returns>
+ 	public static TNumber SquareMeters<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber());
+ 
+ 	/// <summary>
+ 	/// Converts a value to square kilometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square kilometers.</returns>
+ 	public static Area SquareKilometers<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.Kilo * PhysicalConstants.Kilo);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square kilometers.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square kilometers.</returns>
+ 	public static TNumber SquareKilometers<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Kilo * PhysicalConstants.Kilo));
+ 
+ 	/// <summary>
+ 	/// Converts a value to square centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square centimeters.</returns>
+ 	public static Area SquareCentimeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.Centi * PhysicalConstants.Centi);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square centimeters.</returns>
+ 	public static TNumber SquareCentimeters<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Centi * PhysicalConstants.Centi));
+ 
+ 	/// <summary>
+ 	/// Converts a value to square millimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square millimeters.</returns>
+ 	public static Area SquareMillimeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.Milli * PhysicalConstants.Milli);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square millimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square millimeters.</returns>
+ 	public static TNumber SquareMillimeters<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Milli * PhysicalConstants.Milli));
+ 
+ 	// Imperial and other conversions
+ 	/// <summary>
+ 	/// Converts a value to square feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square feet.</returns>
+ 	public static Area SquareFeet<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.FeetToMetersFactor * PhysicalConstants.FeetToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square feet.</returns>
+ 	public static TNumber SquareFeet<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.FeetToMetersFactor * PhysicalConstants.FeetToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to square inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in square inches.</returns>
+ 	public static Area SquareInches<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.InchesToMetersFactor * PhysicalConstants.InchesToMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in square inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in square inches.</returns>
+ 	public static TNumber SquareInches<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.InchesToMetersFactor * PhysicalConstants.InchesToMetersFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to acres.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>An <see cref="Area"/> representing the value in acres.</returns>
+ 	public static Area Acres<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Area>(PhysicalConstants.AcresToSquareMetersFactor);
+ 
+ 	/// <summary>
+ 	/// Converts an <see cref="Area"/> to a numeric value in acres.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Area"/> to convert.</param>
+ 	/// <returns>The numeric value in acres.</returns>
+ 	public static TNumber Acres<TNumber>(this Area value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.AcresToSquareMetersFactor));
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Quantities;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Represents a volume physical quantity.
+ /// </summary>
+ [SIUnit("m³", "cubic meter", "cubic meters")]
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CA2225:Operator overloads have named alternates", Justification = "Physical quantity operations")]
+ public sealed record Volume
+ 	: PhysicalQuantity<Volume>
+ {
+ }
+ 
+ /// <summary>
+ /// Provides extension methods for converting values to and from <see cref="Volume"/>.
+ /// </summary>
+ public static class VolumeConversions
+ {
+ 	/// <summary>
+ 	/// Converts a value to cubic meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in cubic meters.</returns>
+ 	public static Volume CubicMeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>();
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in cubic meters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in cubic meters.</returns>
+ 	public static TNumber CubicMeters<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber());
+ 
+ 	/// <summary>
+ 	/// Converts a value to liters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in liters.</returns>
+ 	public static Volume Liters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(0.001);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in liters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in liters.</returns>
+ 	public static TNumber Liters<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(0.001));
+ 
+ 	/// <summary>
+ 	/// Converts a value to milliliters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in milliliters.</returns>
+ 	public static Volume Milliliters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(1e-6);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in milliliters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in milliliters.</returns>
+ 	public static TNumber Milliliters<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(1e-6));
+ 
+ 	/// <summary>
+ 	/// Converts a value to cubic centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in cubic centimeters.</returns>
+ 	public static Volume CubicCentimeters<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(PhysicalConstants.Centi * PhysicalConstants.Centi * PhysicalConstants.Centi);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in cubic centimeters.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in cubic centimeters.</returns>
+ 	public static TNumber CubicCentimeters<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Centi * PhysicalConstants.Centi * PhysicalConstants.Centi));
+ 
+ 	// Imperial conversions
+ 	/// <summary>
+ 	/// Converts a value to cubic feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in cubic feet.</returns>
+ 	public static Volume CubicFeet<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(Math.Pow(PhysicalConstants.FeetToMetersFactor, 3));
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in cubic feet.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in cubic feet.</returns>
+ 	public static TNumber CubicFeet<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(Math.Pow(PhysicalConstants.FeetToMetersFactor, 3)));
+ 
+ 	/// <summary>
+ 	/// Converts a value to cubic inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in cubic inches.</returns>
+ 	public static Volume CubicInches<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(Math.Pow(PhysicalConstants.InchesToMetersFactor, 3));
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in cubic inches.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in cubic inches.</returns>
+ 	public static TNumber CubicInches<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(Math.Pow(PhysicalConstants.InchesToMetersFactor, 3)));
+ 
+ 	/// <summary>
+ 	/// Converts a value to gallons (US).
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Volume"/> representing the value in gallons.</returns>
+ 	public static Volume Gallons<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Volume>(0.003785411784);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Volume"/> to a numeric value in gallons (US).
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Volume"/> to convert.</param>
+ 	/// <returns>The numeric value in gallons.</returns>
+ 	public static TNumber Gallons<TNumber>(this Volume value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(0.003785411784));
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Quantities;
+ 
+ using System.Numerics;
+ 
+ /// <summary>
+ /// Represents a time physical quantity.
+ /// </summary>
+ [SIUnit("s", "second", "seconds")]
+ [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CA2225:Operator overloads have named alternates", Justification = "Physical quantity operations")]
+ public sealed record Time
+ 	: PhysicalQuantity<Time>
+ {
+ }
+ 
+ /// <summary>
+ /// Provides extension methods for converting values to and from <see cref="Time"/>.
+ /// </summary>
+ public static class TimeConversions
+ {
+ 	/// <summary>
+ 	/// Converts a value to seconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in seconds.</returns>
+ 	public static Time Seconds<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>();
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in seconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in seconds.</returns>
+ 	public static TNumber Seconds<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber());
+ 
+ 	/// <summary>
+ 	/// Converts a value to milliseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in milliseconds.</returns>
+ 	public static Time Milliseconds<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.Milli);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in milliseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in milliseconds.</returns>
+ 	public static TNumber Milliseconds<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Milli));
+ 
+ 	/// <summary>
+ 	/// Converts a value to microseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in microseconds.</returns>
+ 	public static Time Microseconds<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.Micro);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in microseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in microseconds.</returns>
+ 	public static TNumber Microseconds<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Micro));
+ 
+ 	/// <summary>
+ 	/// Converts a value to nanoseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in nanoseconds.</returns>
+ 	public static Time Nanoseconds<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.Nano);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in nanoseconds.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in nanoseconds.</returns>
+ 	public static TNumber Nanoseconds<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.Nano));
+ 
+ 	/// <summary>
+ 	/// Converts a value to minutes.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in minutes.</returns>
+ 	public static Time Minutes<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.MinutesToSecondsFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in minutes.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in minutes.</returns>
+ 	public static TNumber Minutes<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.MinutesToSecondsFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to hours.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in hours.</returns>
+ 	public static Time Hours<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.HoursToSecondsFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in hours.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in hours.</returns>
+ 	public static TNumber Hours<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.HoursToSecondsFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to days.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in days.</returns>
+ 	public static Time Days<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.DaysToSecondsFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in days.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in days.</returns>
+ 	public static TNumber Days<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.DaysToSecondsFactor));
+ 
+ 	/// <summary>
+ 	/// Converts a value to years.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the value to convert.</typeparam>
+ 	/// <param name="value">The value to convert.</param>
+ 	/// <returns>A <see cref="Time"/> representing the value in years.</returns>
+ 	public static Time Years<TNumber>(this TNumber value)
+ 		where TNumber : INumber<TNumber>
+ 		=> value.ConvertToQuantity<TNumber, Time>(PhysicalConstants.YearsToSecondsFactor);
+ 
+ 	/// <summary>
+ 	/// Converts a <see cref="Time"/> to a numeric value in years.
+ 	/// </summary>
+ 	/// <typeparam name="TNumber">The type of the numeric value.</typeparam>
+ 	/// <param name="value">The <see cref="Time"/> to convert.</param>
+ 	/// <returns>The numeric value in years.</returns>
+ 	public static TNumber Years<TNumber>(this Time value)
+ 		where TNumber : INumber<TNumber>
+ 		=> TNumber.CreateChecked(value.ConvertToNumber(PhysicalConstants.YearsToSecondsFactor));
+ } 
```

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Test;
+ 
+ using ktsu.Semantics.Quantities;
+ 
+ [TestClass]
+ public class PhysicalQuantityTests
+ {
+ 	[TestMethod]
+ 	public void Length_BasicConversions_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var meters = 1.0.Meters();
+ 		var centimeters = 100.0.Centimeters();
+ 		var feet = 3.28084.Feet();
+ 
+ 		// Assert
+ 		Assert.AreEqual(1.0, meters.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(100.0, centimeters.Centimeters<double>(), 1e-10);
+ 		Assert.AreEqual(3.28084, feet.Feet<double>(), 1e-5);
+ 
+ 		// Test conversions
+ 		Assert.AreEqual(100.0, meters.Centimeters<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, centimeters.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, feet.Meters<double>(), 1e-5);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Length_ArithmeticOperations_WorkCorrectly()
+ 	{
+ 		// Arrange
+ 		var length1 = 5.0.Meters();
+ 		var length2 = 3.0.Meters();
+ 
+ 		// Act & Assert
+ 		var sum = length1 + length2;
+ 		Assert.AreEqual(8.0, sum.Meters<double>());
+ 
+ 		var difference = length1 - length2;
+ 		Assert.AreEqual(2.0, difference.Meters<double>());
+ 
+ 		var scaled = length1 * 2.0;
+ 		Assert.AreEqual(10.0, scaled.Meters<double>());
+ 
+ 		var divided = length1 / 2.0;
+ 		Assert.AreEqual(2.5, divided.Meters<double>());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Length_MultiplicationCreatesArea_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var length1 = 5.0.Meters();
+ 		var length2 = 4.0.Meters();
+ 
+ 		// Act
+ 		var area = length1 * length2;
+ 
+ 		// Assert
+ 		Assert.IsInstanceOfType<Area>(area);
+ 		Assert.AreEqual(20.0, area.SquareMeters<double>());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Area_BasicConversions_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var squareMeters = 1.0.SquareMeters();
+ 		var squareFeet = 10.7639.SquareFeet();
+ 
+ 		// Assert
+ 		Assert.AreEqual(1.0, squareMeters.SquareMeters<double>(), 1e-10);
+ 		Assert.AreEqual(10.7639, squareFeet.SquareFeet<double>(), 1e-4);
+ 
+ 		// Test conversion
+ 		Assert.AreEqual(1.0, squareFeet.SquareMeters<double>(), 1e-4);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Area_MultiplicationWithLengthCreatesVolume_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var area = 10.0.SquareMeters();
+ 		var height = 3.0.Meters();
+ 
+ 		// Act
+ 		var volume = area * height;
+ 
+ 		// Assert
+ 		Assert.IsInstanceOfType<Volume>(volume);
+ 		Assert.AreEqual(30.0, volume.CubicMeters<double>());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Volume_BasicConversions_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var cubicMeters = 1.0.CubicMeters();
+ 		var liters = 1000.0.Liters();
+ 
+ 		// Assert
+ 		Assert.AreEqual(1.0, cubicMeters.CubicMeters<double>(), 1e-10);
+ 		Assert.AreEqual(1000.0, liters.Liters<double>(), 1e-10);
+ 
+ 		// Test conversion
+ 		Assert.AreEqual(1.0, liters.CubicMeters<double>(), 1e-10);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Time_BasicConversions_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var seconds = 1.0.Seconds();
+ 		var minutes = 1.0.Minutes();
+ 		var hours = 1.0.Hours();
+ 
+ 		// Assert
+ 		Assert.AreEqual(1.0, seconds.Seconds<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, minutes.Minutes<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, hours.Hours<double>(), 1e-10);
+ 
+ 		// Test conversions
+ 		Assert.AreEqual(60.0, minutes.Seconds<double>(), 1e-10);
+ 		Assert.AreEqual(3600.0, hours.Seconds<double>(), 1e-10);
+ 		Assert.AreEqual(60.0, hours.Minutes<double>(), 1e-10);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_Comparison_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var length1 = 5.0.Meters();
+ 		var length2 = 3.0.Meters();
+ 		var length3 = 5.0.Meters();
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(length1 > length2);
+ 		Assert.IsTrue(length2 < length1);
+ 		Assert.IsTrue(length1 >= length3);
+ 		Assert.IsTrue(length1 <= length3);
+ 		Assert.IsTrue(length1 == length3);
+ 		Assert.IsFalse(length1 == length2);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_StringRepresentation_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var length = 5.0.Meters();
+ 		var area = 10.0.SquareMeters();
+ 		var time = 30.0.Seconds();
+ 
+ 		// Act
+ 		var lengthString = length.ToString();
+ 		var areaString = area.ToString();
+ 		var timeString = time.ToString();
+ 
+ 		// Assert
+ 		Assert.IsTrue(lengthString.Contains("5"));
+ 		Assert.IsTrue(lengthString.Contains("m"));
+ 		Assert.IsTrue(areaString.Contains("10"));
+ 		Assert.IsTrue(areaString.Contains("m²"));
+ 		Assert.IsTrue(timeString.Contains("30"));
+ 		Assert.IsTrue(timeString.Contains("s"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_AbsAndClamp_WorkCorrectly()
+ 	{
+ 		// Arrange
+ 		var negativeLength = (-5.0).Meters();
+ 		var positiveLength = 10.0.Meters();
+ 
+ 		// Act
+ 		var absoluteLength = negativeLength.Abs();
+ 		var clampedLength = positiveLength.Clamp(2.0, 8.0);
+ 
+ 		// Assert
+ 		Assert.AreEqual(5.0, absoluteLength.Meters<double>());
+ 		Assert.AreEqual(8.0, clampedLength.Meters<double>());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_Power_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var length = 3.0.Meters();
+ 
+ 		// Act
+ 		var squared = length.Pow(2);
+ 		var cubed = length.Pow(3);
+ 
+ 		// Assert
+ 		Assert.AreEqual(9.0, squared.Meters<double>());
+ 		Assert.AreEqual(27.0, cubed.Meters<double>());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_CompareTo_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var length1 = 5.0.Meters();
+ 		var length2 = 3.0.Meters();
+ 		var length3 = 5.0.Meters();
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(length1.CompareTo(length2) > 0);
+ 		Assert.IsTrue(length2.CompareTo(length1) < 0);
+ 		Assert.AreEqual(0, length1.CompareTo(length3));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_ImperialConversions_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var inches = 12.0.Inches();
+ 		var feet = 1.0.Feet();
+ 		var yards = (1.0 / 3.0).Yards();
+ 
+ 		// Assert - all should be approximately equal
+ 		Assert.AreEqual(feet.Meters<double>(), inches.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(feet.Meters<double>(), yards.Meters<double>(), 1e-10);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void PhysicalQuantity_MetricPrefixes_WorkCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var meters = 1.0.Meters();
+ 		var kilometers = 0.001.Kilometers();
+ 		var centimeters = 100.0.Centimeters();
+ 		var millimeters = 1000.0.Millimeters();
+ 
+ 		// Assert - all should be equal to 1 meter
+ 		Assert.AreEqual(1.0, meters.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, kilometers.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, centimeters.Meters<double>(), 1e-10);
+ 		Assert.AreEqual(1.0, millimeters.Meters<double>(), 1e-10);
+ 	}
+ } 
```

---



---

```bash
dotnet build
```

```
C:\dev\ktsu-dev\Semantics>dotnet build

  C:\dev\ktsu-dev\Semantics\Semantics.sln                                                                Restore (0.0s)
Restore complete (1.3s)
  Semantics failed with 47 error(s) (4.4s)
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(22,59): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(24,58): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its proo
n levellevellevel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticRelativePath.cs(58,10): error CS0122: 'SemanticString<TDerived>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\PhysicalQuantity.cs(43,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008)  
    C:\dev\ktsu-dev\Semantics\Semantics\PhysicalQuantity.cs(44,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008)  
    C:\dev\ktsu-dev\Semantics\Semantics\PhysicalQuantity.cs(45,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008)  
    C:\dev\ktsu-dev\Semantics\Semantics\PhysicalQuantity.cs(46,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008)  
    C:\dev\ktsu-dev\Semantics\Semantics\PhysicalQuantity.cs(47,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008)  

Build failed with 47 error(s) in 6.2s

C:\dev\ktsu-dev\Semantics>
```

---



---



---



---

```bash
dotnet test --filter "TestMethod=*PhysicalQuantity*" --verbosity minimal
```

```

Restore complete (0.6s)
  Semantics failed with 42 error(s) (1.0s)
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(24,58): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(22,59): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(28,29): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(24,58): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(24,11): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(28,26): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(33,25): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(40,31): error CS0122: 'SemanticString<TDerived>.FromString<TDest>(string?)' is inaccessible due to its protection level       
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(31,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(32,35): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(62,31): error CS0122: 'SemanticString<TDerived>.FromCharArray<TDest>(char[]?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(40,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticDirectoryPath.cs(82,12): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticDirectoryPath.cs(90,17): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level       
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(84,31): error CS0122: 'SemanticString<TDerived>.FromReadOnlySpan<TDest>(ReadOnlySpan<char>)' is inaccessible due to its protec
tion level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(51,26): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(56,25): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(54,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(54,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(63,39): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(68,54): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(64,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(64,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(72,20): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticRelativePath.cs(58,10): error CS0122: 'SemanticString<TDerived>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(80,3): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(91,20): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(95,10): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(60,18): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(64,27): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(99,3): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(111,27): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(76,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(114,10): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(82,10): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(123,32): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(130,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(98,19): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(213,32): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level

Build failed with 42 error(s) in 2.0s

C:\dev\ktsu-dev\Semantics>
```

---

_**User**_

I fixed the formatting errors but we still have these:

Restore complete (0.6s)
  Semantics failed with 42 error(s) (0.9s)
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(22,59): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(24,11): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(28,29): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(32,35): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(24,58): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(24,58): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(40,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(54,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(54,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticRelativePath.cs(58,10): error CS0122: 'SemanticString<TDerived>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(28,26): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(33,25): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(64,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(64,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(31,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(76,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(51,26): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(56,25): error CS0122: 'SemanticString<FileExtension>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(63,39): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(72,20): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticFilePath.cs(68,54): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(60,18): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(64,27): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(82,10): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(40,31): error CS0122: 'SemanticString<TDerived>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(62,31): error CS0122: 'SemanticString<TDerived>.FromCharArray<TDest>(char[]?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Strings\SemanticStringExtensions.cs(84,31): error CS0122: 'SemanticString<TDerived>.FromReadOnlySpan<TDest>(ReadOnlySpan<char>)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(98,19): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticDirectoryPath.cs(82,12): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\SemanticDirectoryPath.cs(90,17): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(80,3): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(95,10): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(91,20): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(99,3): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(111,27): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(123,32): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(114,10): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(143,10): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(130,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(213,32): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection level

Build failed with 42 error(s) in 2.0s
  00:57:31   Semantics  12.187s   1 - ERROR 
  10:57:31 main  ?10 ~1
 PS C:\dev\ktsu-dev\Semantics >

---

_**Assistant**_



---

I can see the compilation errors are related to the `FromString<TDest>` method being inaccessible due to its protection level. Let me examine the `SemanticString` class to understand what's happening.

---

<details>
            <summary>Searched codebase "FromString method SemanticString" • **0** results</summary>
        
No results found
</details>

---

Let me search more specifically for the SemanticString class:

---

<details>
            <summary>Searched codebase "SemanticString.cs" • **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Read file: Semantics/Semantics/Strings/SemanticString.cs

---

I can see the issue now. The `FromString<TDest>` method is marked as `private` (around line 658), but the code is trying to use it from extension methods and other classes. Let me examine the specific places where this method is being called to understand the pattern:

---

Read file: Semantics/Semantics/Strings/SemanticStringExtensions.cs

---

Now I understand the issue. The problem is that the extension methods and other parts of the codebase are trying to call `FromString<TDest>`, `FromCharArray<TDest>`, and `FromReadOnlySpan<TDest>` methods, but these are private methods in the `SemanticString<TDerived>` class. 

The solution is to either:
1. Make these methods public/internal, or
2. Use the public `Create<TDest>` methods instead

Looking at the SemanticString class, I can see there are public `Create<TDest>` methods that perform the same functionality. Let me fix the extension methods and other places to use these public methods instead:

---



---



---



---

Now I need to fix the As<TDest>() method in SemanticString itself. Looking at the SemanticString class, I can see the As<TDest>() method uses FromString<TDest>. This should use Create<TDest> as well:

---



---

Now I need to fix all the Path implementations that are calling the private FromString methods. Let me start with a few key files to understand the pattern and then make the necessary changes:

---

<details>
            <summary>Grep search for "FromString<" • **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L13 | `TestStringWithRegexOptions testString = SemanticString<TestStringWithRegexOptions>.FromString<TestStringWithRegexOptions>("ABC123");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L24 | `SemanticString<TestStringWithRegexOptions>.FromString<TestStringWithRegexOptions>("abc123"));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L31 | `TestStringWithCaseInsensitivePrefix testString = SemanticString<TestStringWithCaseInsensitivePrefix>.FromString<TestStringWithCaseInsensitivePrefix>("PREFIX_test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L41 | `TestStringWithCaseInsensitivePrefix testString = SemanticString<TestStringWithCaseInsensitivePrefix>.FromString<TestStringWithCaseInsensitivePrefix>("prefix_test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L52 | `SemanticString<TestStringWithCaseInsensitivePrefix>.FromString<TestStringWithCaseInsensitivePrefix>("wrong_test"));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L59 | `TestStringWithBasicMultipleValidations testString = SemanticString<TestStringWithBasicMultipleValidations>.FromString<TestStringWithBasicMultipleValidations>("PREFIX_contains_SUFFIX");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L70 | `SemanticString<TestStringWithBasicMultipleValidations>.FromString<TestStringWithBasicMultipleValidations>("PREFIX_no_suffix"));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L77 | `TestStringWithCaseInsensitiveContains testString = SemanticString<TestStringWithCaseInsensitiveContains>.FromString<TestStringWithCaseInsensitiveContains>("test MIDDLE end");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L87 | `TestStringWithCaseInsensitiveEnding testString = SemanticString<TestStringWithCaseInsensitiveEnding>.FromString<TestStringWithCaseInsensitiveEnding>("test END");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L97 | `TestStringWithCaseInsensitiveEnding testString = SemanticString<TestStringWithCaseInsensitiveEnding>.FromString<TestStringWithCaseInsensitiveEnding>("test end");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L107 | `TestStringWithCaseInsensitivePrefixSuffix testString = SemanticString<TestStringWithCaseInsensitivePrefixSuffix>.FromString<TestStringWithCaseInsensitivePrefixSuffix>("START_middle_end");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L118 | `SemanticString<TestStringWithPrefix>.FromString<TestStringWithPrefix>(""));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L126 | `SemanticString<TestStringWithPrefix>.FromString<TestStringWithPrefix>("P"));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L136 | `TestStringWithPrefixAndSuffix testString = SemanticString<TestStringWithPrefixAndSuffix>.FromString<TestStringWithPrefixAndSuffix>(longString);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L146 | `TestStringWithSpecialChars testString = SemanticString<TestStringWithSpecialChars>.FromString<TestStringWithSpecialChars>("test@#$%^&*()middle!@#$end");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L156 | `TestStringWithUnicode testString = SemanticString<TestStringWithUnicode>.FromString<TestStringWithUnicode>("🚀test emoji🌟");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L167 | `SemanticString<TestStringWithStrictAnyValidation>.FromString<TestStringWithStrictAnyValidation>("none"));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/ValidationStrategyTests.cs` | L174 | `TestStringWithNoValidation testString = SemanticString<TestStringWithNoValidation>.FromString<TestStringWithNoValidation>("any string");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L19 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L35 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L46 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L54 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>(string.Empty);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L61 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L68 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L76 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L117 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L125 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L133 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L140 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L150 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L159 | `MySemanticString semanticString1 = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L160 | `MySemanticString semanticString2 = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L161 | `MySemanticString semanticString3 = SemanticString<MySemanticString>.FromString<MySemanticString>("apple");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L170 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L179 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L187 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L195 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L203 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L212 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L221 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L230 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L239 | `MySemanticString semanticString1 = SemanticString<MySemanticString>.FromString<MySemanticString>("apple");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L240 | `MySemanticString semanticString2 = SemanticString<MySemanticString>.FromString<MySemanticString>("banana");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L241 | `MySemanticString semanticString3 = SemanticString<MySemanticString>.FromString<MySemanticString>("apple");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L255 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L269 | `SemanticString<MySemanticString>.FromString<MySemanticString>(null));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L290 | `MySemanticString original = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L322 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L342 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L350 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L358 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L375 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L390 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L398 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L406 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L414 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L422 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L430 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L438 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L449 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L457 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L465 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L473 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L481 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L489 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello,world;test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L497 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("a,b,c,d");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L505 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello::world::test");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L513 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L521 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L529 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("HELLO World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L537 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L545 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("HELLO World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L553 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L561 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("  hello world  ");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L569 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("xxhello worldxx");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L577 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("xxhello worldxx");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L585 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("xxhello worldxx");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L593 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L601 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L609 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L617 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L625 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L633 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L641 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L649 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L657 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L665 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L673 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L681 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L689 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L697 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("HELLO");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L705 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L713 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L721 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World Hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L733 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("Hello World Hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L745 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L760 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello world hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L775 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L782 | `MySemanticString semanticString = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticStringTests.cs` | L789 | `MySemanticString semanticString1 = SemanticString<MySemanticString>.FromString<MySemanticString>("hello");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L345 | `public static explicit operator SemanticString<TDerived>(string? value) => FromString<TDerived>(value: value);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L504 | `private static TDest FromString<TDest>(string? value)` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L529 | `return FromString<TDest>(value: new string(value: value));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L548 | `=> FromString<TDest>(value: value.ToString());` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L598 | `public static TDerived Create(string? value) => FromString<TDerived>(value);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L748 | `private static bool TryFromString<TDest>(string? value, out TDest? result)` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Strings/SemanticString.cs` | L759 | `result = FromString<TDest>(value);` |

</details>

---

I see the issue is widespread. The problem is that many places in the codebase are calling the private `FromString<TDest>` method directly. I need to either:

1. Make these private methods internal/public, or  
2. Replace all calls with the public `Create<TDest>` method

However, looking more carefully at the SemanticString class, I noticed that there are some operator overloads and internal usage that legitimately use the private methods. The issue is specifically with external classes trying to call these private methods.

Let me check what the explicit operator is doing:

---

Read file: Semantics/Semantics/Strings/SemanticString.cs

---

I see the issue now. The problem is that the explicit operators inside the SemanticString class are calling the private FromString methods. However, I notice the explicit operator (string→SemanticString) can instead call the public Create method. Let me update the operators:

---



---



---

Now I need to fix the non-generic Create methods that still call the private FromString methods:

---



---



---



---

Now I need to search for the specific Path classes that are trying to call FromString directly. Let me look at a few of the error messages to understand which files need to be fixed:

---

<details>
            <summary>Grep search for "FromString<" • **8** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticRelativePath.cs` | L57 | `return FromString<TRelativePath>(relativePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L27 | `return FileExtension.FromString<FileExtension>("");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L32 | `return FileExtension.FromString<FileExtension>(extension.ToString());` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L50 | `return FileExtension.FromString<FileExtension>("");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L55 | `return FileExtension.FromString<FileExtension>(fullExtension.ToString());` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L62 | `public FileName FileName => FileName.FromString<FileName>(Path.GetFileName(WeakString));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticFilePath.cs` | L67 | `public DirectoryPath DirectoryPath => DirectoryPath.FromString<DirectoryPath>(Path.GetDirectoryName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticDirectoryPath.cs` | L81 | `FilePath.FromString<FilePath>(filePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/SemanticDirectoryPath.cs` | L89 | `DirectoryPath.FromString<DirectoryPath>(directoryPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L23 | `return _cachedDirectoryPath ??= RelativeDirectoryPath.FromString<RelativeDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L39 | `return _cachedFileNameWithoutExtension ??= FileName.FromString<FileName>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L53 | `return FromString<RelativeFilePath>(newPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L63 | `return FromString<RelativeFilePath>(pathWithoutExtension);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L75 | `return AbsoluteFilePath.FromString<AbsoluteFilePath>(absolutePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L21 | `public RelativeDirectoryPath Parent => _cachedParent ??= FromString<RelativeDirectoryPath>(Path.GetDirectoryName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L30 | `public FileName Name => _cachedName ??= FileName.FromString<FileName>(Path.GetFileName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L71 | `RelativeFilePath.FromString<RelativeFilePath>(filePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L79 | `FromString<RelativeDirectoryPath>(directoryPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L94 | `return FromString<RelativeDirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L110 | `return RelativeFilePath.FromString<RelativeFilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L122 | `return AbsoluteDirectoryPath.FromString<AbsoluteDirectoryPath>(absolutePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L142 | `return FromString<RelativeDirectoryPath>(normalized);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L23 | `return FromString<DirectoryPath>(parentPath ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L31 | `public FileName Name => FileName.FromString<FileName>(Path.GetFileName(WeakString));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L59 | `yield return FromString<DirectoryPath>(item);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L63 | `yield return FilePath.FromString<FilePath>(item);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L81 | `return FromString<DirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L97 | `return FilePath.FromString<FilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L23 | `return _cachedDirectoryPath ??= AbsoluteDirectoryPath.FromString<AbsoluteDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L39 | `return _cachedFileNameWithoutExtension ??= FileName.FromString<FileName>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L53 | `return FromString<AbsoluteFilePath>(newPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L63 | `return FromString<AbsoluteFilePath>(pathWithoutExtension);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L27 | `return _cachedParent ??= FromString<AbsoluteDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L39 | `public FileName Name => _cachedName ??= FileName.FromString<FileName>(Path.GetFileName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L90 | `AbsoluteFilePath.FromString<AbsoluteFilePath>(filePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L98 | `FromString<AbsoluteDirectoryPath>(directoryPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L113 | `return FromString<AbsoluteDirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L129 | `return AbsoluteFilePath.FromString<AbsoluteFilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L212 | `return RelativeDirectoryPath.FromString<RelativeDirectoryPath>(relativePath);` |

</details>

---

Perfect! I can see all the files that need to be updated. I need to replace all instances of `FromString<` with `Create<` in these path files. Let me start with systematic fixes:

---



---



---

Let me read the file to see both occurrences and replace them one by one:

---

Read file: Semantics/Semantics/Paths/SemanticFilePath.cs

---

Now I can fix each one individually with more context:

---



---



---



---



---



---



---

Now let me continue with the next file:

---



---



---



---

Now let's continue with the implementation files. I'll use grep to do batch replacements since these are repetitive patterns:

---

```bash
find "Semantics/Semantics/Paths" -name "*.cs" -exec sed -i 's/\.FromString</\.Create</g' {} \;
```

```
C:\dev\ktsu-dev\Semantics>find "Semantics/Semantics/Paths" -name "*.cs" -exec sed -i 's/\.FromString</\.Create</g' {} \;
Microsoft Windows [Version 10.0.26100.4061]
(c) Microsoft Corporation. All rights reserved.

C:\dev\ktsu-dev\Semantics>find "Semantics/Semantics/Paths" -name "*.cs" -exec sed -i 's/\.FromString</\.Create</g' {} \;
The system cannot find the file specified.

C:\dev\ktsu-dev\Semantics>





















C:\dev\ktsu-dev\Semantics>
```

---

The Windows `find` didn't work as expected. Let me use PowerShell for this instead:

---

```bash
powershell -Command "Get-ChildItem -Path 'Semantics\Semantics\Paths' -Recurse -Filter '*.cs' | ForEach-Object { (Get-Content $_.FullName) -replace '\.FromString<', '.Create<' | Set-Content $_.FullName }"
```

```
C:\dev\ktsu-dev\Semantics>powershell -Command "Get-ChildItem -Path 'Semantics\Semantics\Paths' -Recurse -Filter '*.cs' | ForEach-Object { (Get-Content $_.FullName) -replace '\.FromString<', '.Create<
' | Set-Content $_.FullName }"

C:\dev\ktsu-dev\Semantics>
```

---

Perfect! Now let me check if there are any remaining FromString calls in the test files or other locations that need to be fixed:

---

```bash
powershell -Command "Get-ChildItem -Path 'Semantics.Test' -Recurse -Filter '*.cs' | ForEach-Object { (Get-Content $_.FullName) -replace '\.FromString<', '.Create<' | Set-Content $_.FullName }"
```

```
C:\dev\ktsu-dev\Semantics>powershell -Command "Get-ChildItem -Path 'Semantics.Test' -Recurse -Filter '*.cs' | ForEach-Object { (Get-Content $_.FullName) -replace '\.FromString<', '.Create<' | Set-Con
tent $_.FullName }"

C:\dev\ktsu-dev\Semantics>
```

---

Now let's run the build to see if all the compilation errors are resolved:

---

```bash
dotnet build
```

```
C:\dev\ktsu-dev\Semantics>dotnet build

  C:\dev\ktsu-dev\Semantics\Semantics.sln                                                                Restore (0.0s)
Restore complete (0.7s)
  Semantics failed with 30 error(s) (0.5s)
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(24,11): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(22,59): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(28,29): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(32,35): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(40,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(31,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(24,58): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(24,58): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(54,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(54,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(64,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(64,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(72,20): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(76,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(80,3): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(91,20): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(95,10): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(99,3): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(60,18): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(64,27): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(111,27): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(114,10): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(82,10): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(123,32): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(130,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(98,19): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(213,32): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level

Build failed with 30 error(s) in 1.6s

C:\dev\ktsu-dev\Semantics>
```

---

It looks like my PowerShell replacement didn't work correctly - there are still `FromString` calls that weren't replaced properly. Let me check what went wrong and fix the remaining ones manually. Let me look at one of the files to see what the current state is:

---

Read file: Semantics/Semantics/Paths/Implementations/DirectoryPath.cs

---

I can see that the PowerShell replacement didn't work. The FromString calls are still there. Let me manually fix the remaining files by using the search_replace tool systematically. First, let me get a count of how many remaining FromString calls there are:

---

<details>
            <summary>Grep search for "FromString<" • **5** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L23 | `return _cachedDirectoryPath ??= RelativeDirectoryPath.FromString<RelativeDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L39 | `return _cachedFileNameWithoutExtension ??= FileName.FromString<FileName>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L53 | `return FromString<RelativeFilePath>(newPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L63 | `return FromString<RelativeFilePath>(pathWithoutExtension);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeFilePath.cs` | L75 | `return AbsoluteFilePath.FromString<AbsoluteFilePath>(absolutePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L21 | `public RelativeDirectoryPath Parent => _cachedParent ??= FromString<RelativeDirectoryPath>(Path.GetDirectoryName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L30 | `public FileName Name => _cachedName ??= FileName.FromString<FileName>(Path.GetFileName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L71 | `RelativeFilePath.FromString<RelativeFilePath>(filePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L79 | `FromString<RelativeDirectoryPath>(directoryPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L94 | `return FromString<RelativeDirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L110 | `return RelativeFilePath.FromString<RelativeFilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L122 | `return AbsoluteDirectoryPath.FromString<AbsoluteDirectoryPath>(absolutePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/RelativeDirectoryPath.cs` | L142 | `return FromString<RelativeDirectoryPath>(normalized);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L23 | `return FromString<DirectoryPath>(parentPath ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L31 | `public FileName Name => FileName.FromString<FileName>(Path.GetFileName(WeakString));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L59 | `yield return FromString<DirectoryPath>(item);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L63 | `yield return FilePath.FromString<FilePath>(item);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L81 | `return FromString<DirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/DirectoryPath.cs` | L97 | `return FilePath.FromString<FilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L23 | `return _cachedDirectoryPath ??= AbsoluteDirectoryPath.FromString<AbsoluteDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L39 | `return _cachedFileNameWithoutExtension ??= FileName.FromString<FileName>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L53 | `return FromString<AbsoluteFilePath>(newPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteFilePath.cs` | L63 | `return FromString<AbsoluteFilePath>(pathWithoutExtension);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L27 | `return _cachedParent ??= FromString<AbsoluteDirectoryPath>(` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L39 | `public FileName Name => _cachedName ??= FileName.FromString<FileName>(Path.GetFileName(WeakString) ?? "");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L90 | `AbsoluteFilePath.FromString<AbsoluteFilePath>(filePath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L98 | `FromString<AbsoluteDirectoryPath>(directoryPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L113 | `return FromString<AbsoluteDirectoryPath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L129 | `return AbsoluteFilePath.FromString<AbsoluteFilePath>(combinedPath);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Paths/Implementations/AbsoluteDirectoryPath.cs` | L212 | `return RelativeDirectoryPath.FromString<RelativeDirectoryPath>(relativePath);` |

</details>

---

I need to fix each of these by replacing `FromString<` with `Create<`. Let me do this systematically:

---

```bash
powershell -Command "Get-ChildItem -Path 'Semantics\Semantics\Paths' -Recurse -Filter '*.cs' | ForEach-Object { $content = Get-Content $_.FullName -Raw; $content = $content -replace 'FromString<', 'Create<'; Set-Content $_.FullName -Value $content -NoNewline }"
```

```
                                                                                                                                                                                                       
powershell -Command "Get-ChildItem -Path 'Semantics\Semantics\Paths' -Recurse -Filter '*.cs' | ForEach-Object { $content = Get-Content $_.FullName -Raw; $content = $content -replace 'FromString<', 'Crea
te<'; Set-Content $_.FullName -Value $content -NoNewline }"

C:\dev\ktsu-dev\Semantics>
```

---

Now let's test the build again to see if we fixed all the errors:

---

```bash
dotnet build
```

```

Restore complete (0.6s)
  Semantics failed with 30 error(s) (0.5s)
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(28,29): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(24,11): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(22,59): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(40,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(32,35): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(24,58): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(31,51): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection l
evel
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(24,58): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(40,56): error CS0122: 'SemanticString<FileName>.FromString<TDest>(string?)' is inaccessible due to its protection level 
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(54,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteFilePath.cs(64,10): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(54,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(64,10): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(91,20): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(99,3): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(72,20): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its prot
ection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(114,10): error CS0122: 'SemanticString<AbsoluteDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeFilePath.cs(76,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its protectio
n level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(80,3): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its 
protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(130,27): error CS0122: 'SemanticString<AbsoluteFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(60,18): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(64,27): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(82,10): error CS0122: 'SemanticString<DirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its protection leve
l
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(95,10): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to its
 protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\RelativeDirectoryPath.cs(111,27): error CS0122: 'SemanticString<RelativeFilePath>.FromString<TDest>(string?)' is inaccessible due to its pro
tection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\DirectoryPath.cs(98,19): error CS0122: 'SemanticString<FilePath>.FromString<TDest>(string?)' is inaccessible due to its protection level    
s protection level
    C:\dev\ktsu-dev\Semantics\Semantics\Paths\Implementations\AbsoluteDirectoryPath.cs(213,32): error CS0122: 'SemanticString<RelativeDirectoryPath>.FromString<TDest>(string?)' is inaccessible due to it
s protection level

Build failed with 30 error(s) in 1.5s

C:\dev\ktsu-dev\Semantics>
```

---

The PowerShell command didn't work as expected. Let me check what's happening by looking at one of the files again:

---

Read file: Semantics/Semantics/Paths/Implementations/DirectoryPath.cs

---

