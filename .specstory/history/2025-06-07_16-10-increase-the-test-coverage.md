<!-- Generated by SpecStory -->

# Increase the test coverage (2025-06-08 02:10:50)

_**User**_

increase the test coverage

---

_**Assistant**_



---

I'll help you increase the test coverage for your Semantics project. Let me first explore the current project structure and existing tests to understand what's already covered and identify areas that need more testing.

---

<details>
            <summary>Listed directory Semantics • **17** results</summary>
        
| Name |
|-------|
| 📄 `ISemanticString.cs` |
| 📁 `obj` |
| 📄 `SemanticStringContracts.cs` |
| 📄 `SemanticStringFactory.cs` |
| 📄 `IValidationRule.cs` |
| 📄 `SemanticStringValidationAttributes.cs` |
| 📄 `IValidationStrategy.cs` |
| 📄 `ISemanticStringFactory.cs` |
| 📄 `SemanticPathValidationAttributes.cs` |
| 📄 `SemanticString.cs` |
| 📄 `SemanticPath.cs` |
| 📄 `SemanticPathTypes.cs` |
| 📄 `SemanticStringExtensions.cs` |
| 📄 `Semantics.csproj` |
| 📄 `SemanticQuantity.cs` |
| 📁 `bin` |
| 📄 `SemanticStringValidationExamples.cs` |

</details>

---

<details>
            <summary>Listed directory Semantics.Test • **8** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SemanticPathTests.cs` |
| 📄 `SemanticQuantityTests.cs` |
| 📄 `AdvancedAttributeValidationTests.cs` |
| 📄 `AttributeValidationTests.cs` |
| 📄 `SemanticStringTests.cs` |
| 📁 `bin` |
| 📄 `Semantics.Test.csproj` |

</details>

---

Let me examine the existing test files to understand what's currently covered and then look at the main code files to identify gaps:

---

Read file: Semantics.Test/SemanticStringTests.cs

---

Read file: Semantics.Test/SemanticPathTests.cs

---

Read file: Semantics.Test/SemanticQuantityTests.cs

---

Now let me examine the main source files to understand what functionality isn't being tested:

---

Read file: Semantics/SemanticString.cs

---

Read file: Semantics/SemanticStringFactory.cs

---

Let me also examine the attribute validation files to understand what needs testing:

---

Read file: Semantics.Test/AttributeValidationTests.cs

---

Now let me check what validation attributes are available to understand what's not being tested:

---

Read file: Semantics/SemanticStringValidationAttributes.cs

---

Now let me examine the SemanticStringExtensions to see what extension methods need testing:

---

Read file: Semantics/SemanticStringExtensions.cs

---

Based on my analysis of the codebase and existing tests, I can see several areas where test coverage can be significantly improved. Let me create comprehensive test coverage for the missing functionality:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Test;
+ 
+ [TestClass]
+ public class SemanticStringFactoryTests
+ {
+ 	public record TestSemanticString : SemanticString<TestSemanticString> { }
+ 
+ 	[TestMethod]
+ 	public void Default_ReturnsInstanceOfFactory()
+ 	{
+ 		// Act
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 
+ 		// Assert
+ 		Assert.IsNotNull(factory);
+ 		Assert.IsInstanceOfType<SemanticStringFactory<TestSemanticString>>(factory);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Default_ReturnsSameInstance()
+ 	{
+ 		// Act
+ 		var factory1 = SemanticStringFactory<TestSemanticString>.Default;
+ 		var factory2 = SemanticStringFactory<TestSemanticString>.Default;
+ 
+ 		// Assert
+ 		Assert.AreSame(factory1, factory2);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void FromString_ValidValue_ReturnsSemanticString()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 		const string testValue = "test";
+ 
+ 		// Act
+ 		TestSemanticString result = factory.FromString(testValue);
+ 
+ 		// Assert
+ 		Assert.IsNotNull(result);
+ 		Assert.AreEqual(testValue, result.WeakString);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void FromString_NullValue_ThrowsArgumentNullException()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentNullException>(() => factory.FromString(null));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void FromCharArray_ValidValue_ReturnsSemanticString()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 		char[] testValue = ['t', 'e', 's', 't'];
+ 
+ 		// Act
+ 		TestSemanticString result = factory.FromCharArray(testValue);
+ 
+ 		// Assert
+ 		Assert.IsNotNull(result);
+ 		Assert.AreEqual("test", result.WeakString);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void FromCharArray_NullValue_ThrowsArgumentNullException()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentNullException>(() => factory.FromCharArray(null));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void FromReadOnlySpan_ValidValue_ReturnsSemanticString()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 		ReadOnlySpan<char> testValue = "test".AsSpan();
+ 
+ 		// Act
+ 		TestSemanticString result = factory.FromReadOnlySpan(testValue);
+ 
+ 		// Assert
+ 		Assert.IsNotNull(result);
+ 		Assert.AreEqual("test", result.WeakString);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void TryFromString_ValidValue_ReturnsTrueAndSetsResult()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 		const string testValue = "test";
+ 
+ 		// Act
+ 		bool success = factory.TryFromString(testValue, out TestSemanticString? result);
+ 
+ 		// Assert
+ 		Assert.IsTrue(success);
+ 		Assert.IsNotNull(result);
+ 		Assert.AreEqual(testValue, result.WeakString);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void TryFromString_NullValue_ReturnsFalseAndNullResult()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<TestSemanticString>.Default;
+ 
+ 		// Act
+ 		bool success = factory.TryFromString(null, out TestSemanticString? result);
+ 
+ 		// Assert
+ 		Assert.IsFalse(success);
+ 		Assert.IsNull(result);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void TryFromString_InvalidValue_ReturnsFalseAndNullResult()
+ 	{
+ 		// Arrange
+ 		var factory = SemanticStringFactory<InvalidTestString>.Default;
+ 		const string invalidValue = "invalid"; // This won't pass validation
+ 
+ 		// Act
+ 		bool success = factory.TryFromString(invalidValue, out InvalidTestString? result);
+ 
+ 		// Assert
+ 		Assert.IsFalse(success);
+ 		Assert.IsNull(result);
+ 	}
+ }
+ 
+ [StartsWith("Valid")]
+ public record InvalidTestString : SemanticString<InvalidTestString> { } 
```

---

Let me fix the linter errors by using explicit types instead of `var`:

---



---

Now let me expand the existing SemanticStringTests with more comprehensive tests for functionality that's missing coverage:

---



---

Let me create a comprehensive test file for advanced validation scenarios:

---



---



---

Let me try creating the file directly:

---



---

Let me try to create new test files with comprehensive coverage. First, let me add more tests to the existing SemanticStringTests.cs file:

---



---

Read file: Semantics.Test/SemanticStringTests.cs

---

Great! I can see that many comprehensive tests have already been added. Now let me add more tests to the existing attribute validation tests to increase coverage of edge cases:

---

```diff
  			SemanticString<TestStringWithPrefix>.FromString<TestStringWithPrefix>(""));
  	}
+ 
+ 	[TestMethod]
+ 	public void LengthValidation_ValidLength_ReturnsTrue()
+ 	{
+ 		// Arrange
+ 		TestStringWithLength testString = SemanticString<TestStringWithLength>.FromString<TestStringWithLength>("12345");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void LengthValidation_TooShort_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => SemanticString<TestStringWithLength>.FromString<TestStringWithLength>("123"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void LengthValidation_TooLong_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => SemanticString<TestStringWithLength>.FromString<TestStringWithLength>("1234567890"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void AllowedChars_ValidChars_ReturnsTrue()
+ 	{
+ 		// Arrange
+ 		TestStringWithAllowedChars testString = SemanticString<TestStringWithAllowedChars>.FromString<TestStringWithAllowedChars>("abcABC123");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void AllowedChars_InvalidChars_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => SemanticString<TestStringWithAllowedChars>.FromString<TestStringWithAllowedChars>("abc@123"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NotEmpty_ValidString_ReturnsTrue()
+ 	{
+ 		// Arrange
+ 		TestNotEmptyString testString = SemanticString<TestNotEmptyString>.FromString<TestNotEmptyString>("NotEmpty");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NotEmpty_EmptyString_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => SemanticString<TestNotEmptyString>.FromString<TestNotEmptyString>(""));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NotWhiteSpace_ValidString_ReturnsTrue()
+ 	{
+ 		// Arrange
+ 		TestNotWhiteSpaceString testString = SemanticString<TestNotWhiteSpaceString>.FromString<TestNotWhiteSpaceString>("NotWhiteSpace");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NotWhiteSpace_WhiteSpaceOnly_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => SemanticString<TestNotWhiteSpaceString>.FromString<TestNotWhiteSpaceString>("   "));
+ 	}
+ 
+ 	// Additional comprehensive tests for edge cases
+ 
+ 	[TestMethod]
+ 	public void RegexMatchAttribute_WithIgnoreCase_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithRegexIgnoreCase testString = SemanticString<TestStringWithRegexIgnoreCase>.FromString<TestStringWithRegexIgnoreCase>("ABC123");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void RegexMatchAttribute_WithIgnoreCase_DifferentCase_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithRegexIgnoreCase testString = SemanticString<TestStringWithRegexIgnoreCase>.FromString<TestStringWithRegexIgnoreCase>("abc123");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void StringComparison_OrdinalIgnoreCase_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithCaseInsensitive testString = SemanticString<TestStringWithCaseInsensitive>.FromString<TestStringWithCaseInsensitive>("PREFIX_test_SUFFIX");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void StringComparison_OrdinalIgnoreCase_DifferentCase_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithCaseInsensitive testString = SemanticString<TestStringWithCaseInsensitive>.FromString<TestStringWithCaseInsensitive>("prefix_test_suffix");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void EmptyString_Validation_HandledCorrectly()
+ 	{
+ 		// Arrange
+ 		TestEmptyStringValidation testString = SemanticString<TestEmptyStringValidation>.FromString<TestEmptyStringValidation>("");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void MultipleIdenticalAttributes_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithMultipleIdentical testString = SemanticString<TestStringWithMultipleIdentical>.FromString<TestStringWithMultipleIdentical>("PREFIX_test_PREFIX");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void UnicodeCharacters_InValidation_HandledCorrectly()
+ 	{
+ 		// Arrange
+ 		TestStringWithUnicodeValidation testString = SemanticString<TestStringWithUnicodeValidation>.FromString<TestStringWithUnicodeValidation>("🚀Hello World🌟");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ComplexRegex_Email_ValidatesCorrectly()
+ 	{
+ 		// Arrange
+ 		TestEmailString testString = SemanticString<TestEmailString>.FromString<TestEmailString>("user@example.com");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ComplexRegex_Email_InvalidFormat_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => 
+ 			SemanticString<TestEmailString>.FromString<TestEmailString>("invalid-email"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ValidateAll_WithManyAttributes_ValidString_Succeeds()
+ 	{
+ 		// Arrange
+ 		TestStringWithManyValidations testString = SemanticString<TestStringWithManyValidations>.FromString<TestStringWithManyValidations>("PREFIX_middle_content_SUFFIX");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ValidateAll_WithManyAttributes_OneFails_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => 
+ 			SemanticString<TestStringWithManyValidations>.FromString<TestStringWithManyValidations>("PREFIX_content_SUFFIX"));
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ValidateAny_WithManyAttributes_OneSucceeds_Passes()
+ 	{
+ 		// Arrange
+ 		TestStringWithManyAnyValidations testString = SemanticString<TestStringWithManyAnyValidations>.FromString<TestStringWithManyAnyValidations>("OPTION1_test");
+ 
+ 		// Act & Assert
+ 		Assert.IsTrue(testString.IsValid());
+ 	}
+ 
+ 	[TestMethod]
+ 	public void ValidateAny_WithManyAttributes_AllFail_ThrowsFormatException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<FormatException>(() => 
+ 			SemanticString<TestStringWithManyAnyValidations>.FromString<TestStringWithManyAnyValidations>("none_match"));
+ 	}
  }
  
```

```diff
  
  // Reusing TestStringWithPrefix from AttributeValidationTests.cs
+ 
+ [MinLength(5)]
+ [MaxLength(8)]
+ public record TestStringWithLength : SemanticString<TestStringWithLength> { }
+ 
+ [AllowedChars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")]
+ public record TestStringWithAllowedChars : SemanticString<TestStringWithAllowedChars> { }
+ 
+ [NotEmpty]
+ public record TestNotEmptyString : SemanticString<TestNotEmptyString> { }
+ 
+ [NotWhiteSpace]
+ public record TestNotWhiteSpaceString : SemanticString<TestNotWhiteSpaceString> { }
+ 
+ [RegexMatch("^[a-z]+[0-9]+$", System.Text.RegularExpressions.RegexOptions.IgnoreCase)]
+ public record TestStringWithRegexIgnoreCase : SemanticString<TestStringWithRegexIgnoreCase> { }
+ 
+ [PrefixAndSuffix("prefix", "suffix", StringComparison.OrdinalIgnoreCase)]
+ public record TestStringWithCaseInsensitive : SemanticString<TestStringWithCaseInsensitive> { }
+ 
+ [AllowEmpty]
+ public record TestEmptyStringValidation : SemanticString<TestEmptyStringValidation> { }
+ 
+ [StartsWith("PREFIX")]
+ [StartsWith("PREFIX")]
+ public record TestStringWithMultipleIdentical : SemanticString<TestStringWithMultipleIdentical> { }
+ 
+ [StartsWith("🚀")]
+ [EndsWith("🌟")]
+ public record TestStringWithUnicodeValidation : SemanticString<TestStringWithUnicodeValidation> { }
+ 
+ [RegexMatch(@"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")]
+ public record TestEmailString : SemanticString<TestEmailString> { }
+ 
+ [ValidateAll]
+ [StartsWith("PREFIX")]
+ [EndsWith("SUFFIX")]
+ [Contains("middle")]
+ [Contains("content")]
+ public record TestStringWithManyValidations : SemanticString<TestStringWithManyValidations> { }
+ 
+ [ValidateAny]
+ [StartsWith("OPTION1")]
+ [StartsWith("OPTION2")]
+ [StartsWith("OPTION3")]
+ [EndsWith("ALT1")]
+ [EndsWith("ALT2")]
+ public record TestStringWithManyAnyValidations : SemanticString<TestStringWithManyAnyValidations> { }
  
```

---

I notice that some of the validation attributes I'm using (like `MinLength`, `MaxLength`, `AllowedChars`, `NotEmpty`, `NotWhiteSpace`, `AllowEmpty`) might not actually exist in the codebase. Let me check what validation attributes are available:

---

<details>
            <summary>Grep search for "class.*Attribute.*SemanticStringValidationAttribute" • **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticStringValidationAttributes.cs` | L44 | `public sealed class StartsWithAttribute(string prefix, StringComparison comparison = StringComparison.Ordinal) : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticStringValidationAttributes.cs` | L68 | `public sealed class EndsWithAttribute(string suffix, StringComparison comparison = StringComparison.Ordinal) : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticStringValidationAttributes.cs` | L92 | `public sealed class ContainsAttribute(string substring, StringComparison comparison = StringComparison.Ordinal) : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticStringValidationAttributes.cs` | L116 | `public sealed class PrefixAndSuffixAttribute(string prefix, string suffix, StringComparison comparison = StringComparison.Ordinal) : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticStringValidationAttributes.cs` | L145 | `public sealed class RegexMatchAttribute(string pattern, RegexOptions options = RegexOptions.None) : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L22 | `public sealed class IsPathAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L54 | `public sealed class IsRelativePathAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L86 | `public sealed class IsAbsolutePathAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L106 | `public sealed class IsDirectoryPathAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L130 | `public sealed class IsFilePathAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L154 | `public sealed class IsFileNameAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L182 | `public sealed class DoesExistAttribute : SemanticStringValidationAttribute` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/SemanticPathValidationAttributes.cs` | L208 | `public sealed class IsExtensionAttribute : SemanticStringValidationAttribute` |

</details>

---

I see that only specific validation attributes exist. Let me fix the test file to only use the actual validation attributes:

---



---

Now let me update the corresponding test types at the bottom of the file:

---



---

I need to fix the AllowEmpty attribute issue. Let me remove it since it doesn't exist:

---



---

Now let me create additional tests for the SemanticQuantity edge cases that aren't fully covered:

---



---



---

I'll help you increase test coverage for the Semantics project. Let me start by exploring the current test structure and the main project to understand what needs additional coverage.

---

<details>
            <summary>Listed directory Semantics.Test • **10** results</summary>
        
| Name |
|-------|
| 📄 `SemanticQuantityTests.cs` |
| 📄 `AdvancedAttributeValidationTests.cs` |
| 📄 `ValidationStrategyTests.cs` |
| 📄 `SemanticStringTests.cs` |
| 📄 `SemanticStringFactoryTests.cs` |
| 📁 `obj` |
| 📄 `SemanticPathTests.cs` |
| 📄 `AttributeValidationTests.cs` |
| 📁 `bin` |
| 📄 `Semantics.Test.csproj` |

</details>

---

<details>
            <summary>Listed directory Semantics • **17** results</summary>
        
| Name |
|-------|
| 📄 `ISemanticString.cs` |
| 📁 `obj` |
| 📄 `SemanticStringContracts.cs` |
| 📄 `SemanticStringFactory.cs` |
| 📄 `IValidationRule.cs` |
| 📄 `SemanticStringValidationAttributes.cs` |
| 📄 `IValidationStrategy.cs` |
| 📄 `ISemanticStringFactory.cs` |
| 📄 `SemanticPathValidationAttributes.cs` |
| 📄 `SemanticString.cs` |
| 📄 `SemanticPath.cs` |
| 📄 `SemanticPathTypes.cs` |
| 📄 `SemanticStringExtensions.cs` |
| 📄 `Semantics.csproj` |
| 📄 `SemanticQuantity.cs` |
| 📁 `bin` |
| 📄 `SemanticStringValidationExamples.cs` |

</details>

---





---

_**User**_

continue

---

_**Assistant**_



---

