<!-- Generated by SpecStory -->

# Create docs directory for technical info (2025-06-08 02:02:04)

_**User**_

lets create a docs directory and split out the more technical information from the readme to put in there, the content from the architechture document should also go into an approopriate document in there

---

_**Assistant**_



---

I'll help you create a docs directory and reorganize the technical documentation. Let me first examine the current README and ARCHITECTURE files to understand what content we're working with.

---

Read file: README.md

---

Read file: ARCHITECTURE.md

---

Now let me read the rest of the README to see what other content is there:

---

Read file: README.md

---

Now let me read the rest of the ARCHITECTURE.md file:

---

Read file: ARCHITECTURE.md

---

Perfect! Now I have a clear understanding of the content. Let me create the docs directory and split the content appropriately. I'll:

1. Create a docs directory
2. Move the technical content from README to appropriate docs files
3. Move ARCHITECTURE.md content to the docs directory
4. Update README to be more user-focused and reference the docs

---

```bash
mkdir docs
```

```
C:\dev\ktsu-dev\Semantics>mkdir docs

Microsoft Windows [Version 10.0.26100.4061]
(c) Microsoft Corporation. All rights reserved.

C:\dev\ktsu-dev\Semantics>mkdir docs

C:\dev\ktsu-dev\Semantics>






















C:\dev\ktsu-dev\Semantics>
```

---

Now let me create the documentation files in the docs directory. I'll create several focused documents:

---

```diff
- 
+ # Architecture Guide
+ 
+ This document provides a detailed overview of the Semantics library architecture, focusing on the SOLID principles and DRY practices implemented throughout the codebase.
+ 
+ ## Table of Contents
+ 
+ -   [Overview](#overview)
+ -   [SOLID Principles Implementation](#solid-principles-implementation)
+ -   [DRY Implementation](#dry-implementation)
+ -   [Design Patterns](#design-patterns)
+ -   [Class Hierarchy](#class-hierarchy)
+ -   [Validation System](#validation-system)
+ -   [Testing Strategy](#testing-strategy)
+ 
+ ## Overview
+ 
+ The Semantics library is designed around clean architecture principles, with a focus on maintainability, extensibility, and testability. The core philosophy is to provide type-safe string wrappers while maintaining excellent separation of concerns and avoiding code duplication.
+ 
+ ## SOLID Principles Implementation
+ 
+ ### Single Responsibility Principle (SRP)
+ 
+ Each class has a single, well-defined responsibility:
+ 
+ #### Factory Pattern Implementation
+ 
+ -   **`ISemanticStringFactory<T>`**: Object creation only
+ -   **`SemanticStringFactory<T>`**: Concrete creation logic
+ -   **Purpose**: Separates construction from business logic
+ 
+ #### Validation Strategy Separation
+ 
+ -   **`IValidationStrategy`**: Defines validation processing
+ -   **`ValidateAllStrategy`**: "All must pass" logic
+ -   **`ValidateAnyStrategy`**: "Any can pass" logic
+ -   **`ValidationStrategyFactory`**: Strategy creation
+ 
+ ### Open/Closed Principle (OCP)
+ 
+ Open for extension, closed for modification:
+ 
+ ```csharp
+ // Add new validation rules without modifying existing code
+ public class CustomBusinessRule : ValidationRuleBase
+ {
+     public override string RuleName => "CustomBusiness";
+ 
+     protected override bool ValidateCore(SemanticStringValidationAttribute attribute, ISemanticString value)
+     {
+         // Custom validation logic
+         return true;
+     }
+ }
+ ```
+ 
+ ### Liskov Substitution Principle (LSP)
+ 
+ All implementations are fully substitutable through behavioral contracts:
+ 
+ ```csharp
+ // Contract validation ensures LSP compliance
+ public static class SemanticStringContracts
+ {
+     public static bool ValidateContracts<T>(T instance) where T : SemanticString<T>
+     {
+         // Validates basic contracts (reflexivity, etc.)
+     }
+ 
+     public static bool ValidateEqualityContracts<T>(T? first, T? second) where T : SemanticString<T>
+     {
+         // Validates equality behavior
+     }
+ }
+ ```
+ 
+ ### Interface Segregation Principle (ISP)
+ 
+ Focused, client-specific interfaces:
+ 
+ -   **`ISemanticStringFactory<T>`**: Factory operations only
+ -   **`IValidationStrategy`**: Validation strategy operations only
+ -   **`IValidationRule`**: Individual rule operations only
+ 
+ ### Dependency Inversion Principle (DIP)
+ 
+ High-level modules depend on abstractions:
+ 
+ ```csharp
+ // Service depends on abstraction, not concrete implementation
+ public class UserService
+ {
+     private readonly ISemanticStringFactory<EmailAddress> _emailFactory;
+ 
+     public UserService(ISemanticStringFactory<EmailAddress> emailFactory)
+     {
+         _emailFactory = emailFactory;
+     }
+ }
+ ```
+ 
+ ## DRY Implementation
+ 
+ ### Strategy Pattern for Validation Logic
+ 
+ **Problem Eliminated**: Duplicated validation logic across multiple methods.
+ 
+ **Solution**: Centralized validation strategies with pluggable implementations.
+ 
+ ```csharp
+ public interface IValidationStrategy
+ {
+     bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value);
+ }
+ 
+ // Reusable strategies eliminate duplication
+ public class ValidateAllStrategy : IValidationStrategy { /* implementation */ }
+ public class ValidateAnyStrategy : IValidationStrategy { /* implementation */ }
+ ```
+ 
+ ### Template Method Pattern for Validation Rules
+ 
+ **Problem Eliminated**: Common validation patterns repeated across attribute types.
+ 
+ **Solution**: Base class with template method for common functionality.
+ 
+ ```csharp
+ public abstract class ValidationRuleBase : IValidationRule
+ {
+     // Template method - common structure, specific implementation in derived classes
+     public bool Validate(SemanticStringValidationAttribute attribute, ISemanticString value)
+     {
+         if (!IsApplicable(attribute)) return false;
+         if (value?.ToString() is not string stringValue) return false;
+         return ValidateCore(attribute, value);  // Specific implementation
+     }
+ 
+     protected abstract bool ValidateCore(SemanticStringValidationAttribute attribute, ISemanticString value);
+ }
+ ```
+ 
+ ## Design Patterns
+ 
+ ### Factory Pattern
+ 
+ -   **Purpose**: Encapsulate object creation logic
+ -   **Implementation**: `ISemanticStringFactory<T>` and `SemanticStringFactory<T>`
+ -   **Benefits**: Consistent creation, testability, DI support
+ 
+ ### Strategy Pattern
+ 
+ -   **Purpose**: Interchangeable validation algorithms
+ -   **Implementation**: `IValidationStrategy` with concrete strategies
+ -   **Benefits**: Extensibility, configurable behavior
+ 
+ ### Template Method Pattern
+ 
+ -   **Purpose**: Define algorithm structure with customizable steps
+ -   **Implementation**: `ValidationRuleBase` with abstract methods
+ -   **Benefits**: Code reuse, consistent structure
+ 
+ ## Class Hierarchy
+ 
+ ```
+ ISemanticString
+ ├── SemanticString<TDerived> (abstract base)
+     ├── SemanticPath<TDerived> (path-specific base)
+     │   ├── AbsolutePath
+     │   ├── RelativePath
+     │   ├── FilePath
+     │   ├── DirectoryPath
+     │   ├── FileName
+     │   └── FileExtension
+     └── [Custom semantic string types]
+ 
+ ISemanticStringFactory<T>
+ └── SemanticStringFactory<T>
+ 
+ IValidationStrategy
+ ├── ValidateAllStrategy
+ ├── ValidateAnyStrategy
+ └── [Custom validation strategies]
+ 
+ IValidationRule
+ ├── ValidationRuleBase (abstract)
+ │   ├── LengthValidationRule
+ │   ├── PatternValidationRule
+ │   └── [Custom validation rules]
+ └── [Custom validation rules]
+ ```
+ 
+ ## Validation System
+ 
+ ### Architecture Overview
+ 
+ The validation system follows a layered approach:
+ 
+ 1. **Attribute Layer**: `SemanticStringValidationAttribute` classes
+ 2. **Strategy Layer**: `IValidationStrategy` implementations
+ 3. **Rule Layer**: `IValidationRule` implementations
+ 4. **Factory Layer**: `ValidationStrategyFactory` creates strategies
+ 
+ ### Validation Flow
+ 
+ ```
+ User Creates Semantic String
+            ↓
+     SemanticStringFactory
+            ↓
+    Get Validation Attributes
+            ↓
+    ValidationStrategyFactory.GetStrategy()
+            ↓
+    IValidationStrategy.Validate()
+            ↓
+    For Each Attribute: IValidationRule.Validate()
+            ↓
+    Combine Results (All/Any/Custom)
+            ↓
+    Return Valid Object or Throw Exception
+ ```
+ 
+ ## Testing Strategy
+ 
+ ### Contract Testing
+ 
+ -   All implementations must pass contract validation
+ -   `SemanticStringContracts` provides standardized tests
+ -   Ensures LSP compliance
+ 
+ ### Example Test Structure
+ 
+ ```csharp
+ [Test]
+ public void EmailAddress_ShouldSatisfyContracts()
+ {
+     var email1 = _factory.Create("user1@example.com");
+     var email2 = _factory.Create("user2@example.com");
+     var email3 = _factory.Create("user3@example.com");
+ 
+     Assert.IsTrue(SemanticStringContracts.ValidateContracts(email1));
+     Assert.IsTrue(SemanticStringContracts.ValidateEqualityContracts(email1, email2));
+     Assert.IsTrue(SemanticStringContracts.ValidateComparisonContracts(email1, email2, email3));
+ }
+ ```
+ 
+ This architecture ensures the library remains maintainable, extensible, and testable while providing excellent performance and type safety. 
```

---

```diff
- 
+ # Advanced Usage Guide
+ 
+ This guide covers advanced features and patterns for using the Semantics library effectively in complex scenarios.
+ 
+ ## Table of Contents
+ 
+ -   [Factory Pattern Usage](#factory-pattern-usage)
+ -   [Custom Validation Strategies](#custom-validation-strategies)
+ -   [Contract Validation and LSP Compliance](#contract-validation-and-lsp-compliance)
+ -   [Type Conversions](#type-conversions)
+ -   [Validation Modes](#validation-modes)
+ -   [Path Operations](#path-operations)
+ -   [Best Practices](#best-practices)
+ -   [Dependency Injection](#dependency-injection)
+ 
+ ## Factory Pattern Usage
+ 
+ The factory pattern provides a clean, extensible way to create semantic string instances with proper dependency injection support.
+ 
+ ```csharp
+ // Dependency injection with factories
+ public class UserService
+ {
+     private readonly ISemanticStringFactory<EmailAddress> _emailFactory;
+     private readonly ISemanticStringFactory<UserId> _userIdFactory;
+ 
+     public UserService(
+         ISemanticStringFactory<EmailAddress> emailFactory,
+         ISemanticStringFactory<UserId> userIdFactory)
+     {
+         _emailFactory = emailFactory;
+         _userIdFactory = userIdFactory;
+     }
+ 
+     public User CreateUser(string email, string id)
+     {
+         // Safe creation with automatic validation
+         var emailAddress = _emailFactory.Create(email);
+         var userId = _userIdFactory.Create(id);
+         return new User(userId, emailAddress);
+     }
+ 
+     public bool TryCreateUser(string email, string id, out User? user)
+     {
+         user = null;
+         if (!_emailFactory.TryCreate(email, out var emailAddress) ||
+             !_userIdFactory.TryCreate(id, out var userId))
+         {
+             return false;
+         }
+ 
+         user = new User(userId, emailAddress);
+         return true;
+     }
+ }
+ ```
+ 
+ ## Custom Validation Strategies
+ 
+ Create domain-specific validation strategies that implement complex business rules.
+ 
+ ```csharp
+ // Implement domain-specific validation strategies
+ public class BusinessRuleValidationStrategy : IValidationStrategy
+ {
+     public bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value)
+     {
+         // Custom business logic for validation
+         var criticalAttributes = attributes.Where(attr => attr is ICriticalValidation);
+         var nonCriticalAttributes = attributes.Except(criticalAttributes);
+ 
+         // All critical validations must pass
+         bool criticalPass = criticalAttributes.All(attr => attr.Validate(value));
+ 
+         // At least one non-critical validation must pass
+         bool nonCriticalPass = !nonCriticalAttributes.Any() ||
+                               nonCriticalAttributes.Any(attr => attr.Validate(value));
+ 
+         return criticalPass && nonCriticalPass;
+     }
+ }
+ 
+ // Use custom strategies with validation attributes
+ [ValidateWith(typeof(BusinessRuleValidationStrategy))]
+ [IsNotEmpty, IsEmail] // Critical validations
+ [IsCompanyEmail, IsInternalDomain] // Non-critical validations
+ public sealed record BusinessEmail : SemanticString<BusinessEmail> { }
+ ```
+ 
+ ### Creating Custom Validation Rules
+ 
+ ```csharp
+ // Create reusable validation rules
+ public class ProductCodeValidationRule : ValidationRuleBase
+ {
+     public override string RuleName => "ProductCode";
+ 
+     protected override bool ValidateCore(SemanticStringValidationAttribute attribute, ISemanticString value)
+     {
+         string str = value.ToString();
+         // Product codes: letter + 5 digits
+         return Regex.IsMatch(str, @"^[A-Z][0-9]{5}$");
+     }
+ 
+     public override bool IsApplicable(SemanticStringValidationAttribute attribute)
+         => attribute is IsProductCodeAttribute;
+ }
+ 
+ // Custom validation attribute
+ public class IsProductCodeAttribute : SemanticStringValidationAttribute
+ {
+     public override bool Validate(ISemanticString semanticString)
+     {
+         var rule = new ProductCodeValidationRule();
+         return rule.Validate(this, semanticString);
+     }
+ }
+ 
+ // Apply custom validation
+ [IsProductCode]
+ public sealed record ProductCode : SemanticString<ProductCode> { }
+ 
+ // Usage with automatic validation
+ var factory = new SemanticStringFactory<ProductCode>();
+ var validCode = factory.Create("A12345");   // ✅ Valid
+ // factory.Create("123ABC");                 // ❌ Throws FormatException
+ ```
+ 
+ ## Contract Validation and LSP Compliance
+ 
+ Ensure your implementations satisfy behavioral contracts for proper Liskov Substitution Principle compliance.
+ 
+ ```csharp
+ // Ensure implementations satisfy behavioral contracts
+ public class SemanticStringValidator<T> where T : SemanticString<T>
+ {
+     public bool ValidateImplementation(T instance1, T instance2, T instance3)
+     {
+         // Validate basic contracts (reflexivity, symmetry, transitivity)
+         bool basicContracts = SemanticStringContracts.ValidateContracts(instance1);
+ 
+         // Validate equality contracts
+         bool equalityContracts = SemanticStringContracts.ValidateEqualityContracts(instance1, instance2);
+ 
+         // Validate comparison contracts (for IComparable implementations)
+         bool comparisonContracts = SemanticStringContracts.ValidateComparisonContracts(instance1, instance2, instance3);
+ 
+         return basicContracts && equalityContracts && comparisonContracts;
+     }
+ }
+ 
+ // Use in unit tests to ensure LSP compliance
+ [Test]
+ public void EmailAddress_ShouldSatisfySemanticStringContracts()
+ {
+     var email1 = EmailAddress.FromString<EmailAddress>("user@example.com");
+     var email2 = EmailAddress.FromString<EmailAddress>("admin@example.com");
+     var email3 = EmailAddress.FromString<EmailAddress>("test@example.com");
+ 
+     var validator = new SemanticStringValidator<EmailAddress>();
+     Assert.IsTrue(validator.ValidateImplementation(email1, email2, email3));
+ }
+ ```
+ 
+ ## Type Conversions
+ 
+ The library provides safe conversions between compatible types with zero-allocation optimizations.
+ 
+ ```csharp
+ // Safe conversions between compatible types
+ var factory = new SemanticStringFactory<Path>();
+ var genericPath = factory.Create(@"C:\temp\file.txt");
+ var specificPath = genericPath.As<FilePath>(); // Convert to more specific type
+ 
+ // Implicit conversions to primitive types
+ string pathString = specificPath;              // Implicit to string
+ char[] pathChars = specificPath;               // Implicit to char[]
+ ReadOnlySpan<char> pathSpan = specificPath;    // Implicit to span
+ ```
+ 
+ ## Validation Modes
+ 
+ Configure how multiple validation attributes are processed:
+ 
+ ```csharp
+ // Require ALL validation attributes to pass (default)
+ [ValidateAll]
+ [IsPath, IsAbsolutePath, DoesExist]
+ public sealed record ExistingAbsolutePath : SemanticPath<ExistingAbsolutePath> { }
+ 
+ // Require ANY validation attribute to pass
+ [ValidateAny]
+ [IsEmail, IsUrl]
+ public sealed record ContactInfo : SemanticString<ContactInfo> { }
+ 
+ // Custom validation strategy (shown earlier)
+ [ValidateWith(typeof(BusinessRuleValidationStrategy))]
+ [IsNotEmpty, IsEmail]
+ public sealed record StrictBusinessEmail : SemanticString<StrictBusinessEmail> { }
+ ```
+ 
+ ## Path Operations
+ 
+ Specialized operations for working with file system paths:
+ 
+ ```csharp
+ var from = AbsolutePath.FromString<AbsolutePath>(@"C:\Projects\App");
+ var to = AbsolutePath.FromString<AbsolutePath>(@"C:\Projects\Lib\Utils.cs");
+ 
+ // Create relative path between two absolute paths
+ var relativePath = RelativePath.Make<RelativePath, AbsolutePath, AbsolutePath>(from, to);
+ Console.WriteLine(relativePath); // ..\Lib\Utils.cs
+ 
+ // Use built-in path types with factory pattern
+ var pathFactory = new SemanticStringFactory<FilePath>();
+ var filePath = pathFactory.Create(@"C:\temp\data.json");
+ 
+ // Access path properties
+ Console.WriteLine(filePath.FileName);        // data.json
+ Console.WriteLine(filePath.FileExtension);   // .json
+ Console.WriteLine(filePath.DirectoryPath);   // C:\temp
+ 
+ // Check file system properties
+ var absolutePath = AbsolutePath.FromString<AbsolutePath>(@"C:\Projects\MyApp");
+ Console.WriteLine(absolutePath.Exists);      // True/False
+ Console.WriteLine(absolutePath.IsDirectory); // True/False
+ ```
+ 
+ ## Best Practices
+ 
+ ### SOLID and DRY Principles
+ 
+ 1. **Use Factory Pattern**: Prefer `ISemanticStringFactory<T>` for object creation to separate construction logic
+ 2. **Implement Custom Strategies**: Create domain-specific validation strategies rather than duplicating validation logic
+ 3. **Leverage Contract Validation**: Use `SemanticStringContracts` in unit tests to ensure LSP compliance
+ 4. **Extend Through Interfaces**: Add new functionality through new interfaces rather than modifying existing ones
+ 5. **Compose Validation Rules**: Build complex validation by composing simple, reusable `IValidationRule` implementations
+ 
+ ### Domain Design
+ 
+ 6. **Create Domain-Specific Types**: Use semantic strings for domain concepts like `UserId`, `OrderNumber`, `ProductSku`
+ 7. **Validate at Boundaries**: Create semantic strings at system boundaries (APIs, user input, file I/O)
+ 8. **Use Type Safety**: Let the compiler prevent string misuse with strong typing
+ 9. **Combine Validations**: Use multiple validation attributes for comprehensive checking
+ 10. **Document Intent**: Semantic types make code self-documenting
+ 
+ ## Dependency Injection
+ 
+ Integrate semantic string factories with your dependency injection container:
+ 
+ ```csharp
+ // Register factories in your DI container
+ services.AddTransient<ISemanticStringFactory<EmailAddress>, SemanticStringFactory<EmailAddress>>();
+ services.AddTransient<ISemanticStringFactory<UserId>, SemanticStringFactory<UserId>>();
+ 
+ // Use in controllers/services
+ public class UserController : ControllerBase
+ {
+     private readonly ISemanticStringFactory<EmailAddress> _emailFactory;
+ 
+     public UserController(ISemanticStringFactory<EmailAddress> emailFactory)
+     {
+         _emailFactory = emailFactory;
+     }
+ 
+     [HttpPost]
+     public IActionResult CreateUser([FromBody] CreateUserRequest request)
+     {
+         if (!_emailFactory.TryCreate(request.Email, out var emailAddress))
+         {
+             return BadRequest("Invalid email format");
+         }
+ 
+         // emailAddress is guaranteed to be valid
+         var user = new User(emailAddress);
+         return Ok(user);
+     }
+ }
+ ```
+ 
+ This advanced usage guide demonstrates how to leverage the full power of the Semantics library while maintaining clean, maintainable, and testable code. 
```

---

```diff
- 
+ # Validation Reference
+ 
+ This document provides a comprehensive reference for all built-in validation attributes and validation strategies available in the Semantics library.
+ 
+ ## Table of Contents
+ 
+ -   [Overview](#overview)
+ -   [Built-in Validation Attributes](#built-in-validation-attributes)
+ -   [Built-in Types](#built-in-types)
+ -   [Validation Strategies](#validation-strategies)
+ -   [Custom Validation](#custom-validation)
+ 
+ ## Overview
+ 
+ The Semantics library provides a robust validation system with multiple layers:
+ 
+ - **Validation Attributes**: Decorative attributes that define validation rules
+ - **Validation Strategies**: Control how multiple validation rules are processed
+ - **Validation Rules**: The actual implementation of validation logic
+ - **Built-in Types**: Pre-configured semantic string types with common validations
+ 
+ ## Built-in Validation Attributes
+ 
+ ### String Validation
+ 
+ #### `IsEmailAttribute`
+ Validates email address format using standard email regex patterns.
+ 
+ ```csharp
+ [IsEmail]
+ public sealed record EmailAddress : SemanticString<EmailAddress> { }
+ 
+ var factory = new SemanticStringFactory<EmailAddress>();
+ var email = factory.Create("user@example.com"); // ✅ Valid
+ // factory.Create("invalid-email");              // ❌ Throws FormatException
+ ```
+ 
+ #### `IsUrlAttribute`
+ Validates URL format for both HTTP and HTTPS URLs.
+ 
+ ```csharp
+ [IsUrl]
+ public sealed record WebUrl : SemanticString<WebUrl> { }
+ 
+ var factory = new SemanticStringFactory<WebUrl>();
+ var url = factory.Create("https://example.com"); // ✅ Valid
+ // factory.Create("not-a-url");                   // ❌ Throws FormatException
+ ```
+ 
+ #### `IsNotEmptyAttribute`
+ Prevents empty, null, or whitespace-only strings.
+ 
+ ```csharp
+ [IsNotEmpty]
+ public sealed record NonEmptyString : SemanticString<NonEmptyString> { }
+ 
+ var factory = new SemanticStringFactory<NonEmptyString>();
+ var text = factory.Create("Hello World"); // ✅ Valid
+ // factory.Create("");                     // ❌ Throws FormatException
+ // factory.Create("   ");                  // ❌ Throws FormatException
+ ```
+ 
+ #### `HasLengthAttribute`
+ Constrains string length to specified minimum and maximum values.
+ 
+ ```csharp
+ [HasLength(5, 20)] // Min 5, Max 20 characters
+ public sealed record Username : SemanticString<Username> { }
+ 
+ var factory = new SemanticStringFactory<Username>();
+ var username = factory.Create("johndoe"); // ✅ Valid (7 characters)
+ // factory.Create("abc");                  // ❌ Throws FormatException (too short)
+ // factory.Create("verylongusernamethatexceedslimit"); // ❌ Throws FormatException (too long)
+ ```
+ 
+ ### Path Validation
+ 
+ #### `IsPathAttribute`
+ Validates that the string represents a valid path with legal characters and appropriate length.
+ 
+ ```csharp
+ [IsPath]
+ public sealed record GenericPath : SemanticString<GenericPath> { }
+ 
+ var factory = new SemanticStringFactory<GenericPath>();
+ var path = factory.Create(@"C:\temp\file.txt"); // ✅ Valid
+ // factory.Create("C:\\invalid<>path");          // ❌ Throws FormatException
+ ```
+ 
+ #### `IsAbsolutePathAttribute`
+ Validates fully qualified, absolute paths.
+ 
+ ```csharp
+ [IsAbsolutePath]
+ public sealed record AbsolutePath : SemanticString<AbsolutePath> { }
+ 
+ var factory = new SemanticStringFactory<AbsolutePath>();
+ var absPath = factory.Create(@"C:\Projects\App"); // ✅ Valid
+ // factory.Create("relative\path");               // ❌ Throws FormatException
+ ```
+ 
+ #### `IsRelativePathAttribute`
+ Validates relative paths (not starting from root).
+ 
+ ```csharp
+ [IsRelativePath]
+ public sealed record RelativePath : SemanticString<RelativePath> { }
+ 
+ var factory = new SemanticStringFactory<RelativePath>();
+ var relPath = factory.Create(@"subfolder\file.txt"); // ✅ Valid
+ // factory.Create(@"C:\absolute\path");               // ❌ Throws FormatException
+ ```
+ 
+ #### `IsFilePathAttribute`
+ Validates paths that point to files (not directories).
+ 
+ ```csharp
+ [IsFilePath]
+ public sealed record FilePath : SemanticString<FilePath> { }
+ 
+ var factory = new SemanticStringFactory<FilePath>();
+ var filePath = factory.Create(@"C:\temp\document.pdf"); // ✅ Valid
+ // factory.Create(@"C:\temp\");                         // ❌ Throws FormatException (directory)
+ ```
+ 
+ #### `IsDirectoryPathAttribute`
+ Validates paths that point to directories.
+ 
+ ```csharp
+ [IsDirectoryPath]
+ public sealed record DirectoryPath : SemanticString<DirectoryPath> { }
+ 
+ var factory = new SemanticStringFactory<DirectoryPath>();
+ var dirPath = factory.Create(@"C:\Projects\"); // ✅ Valid
+ // factory.Create(@"C:\file.txt");              // ❌ Throws FormatException (file)
+ ```
+ 
+ #### `IsFileNameAttribute`
+ Validates filenames without path separators.
+ 
+ ```csharp
+ [IsFileName]
+ public sealed record FileName : SemanticString<FileName> { }
+ 
+ var factory = new SemanticStringFactory<FileName>();
+ var fileName = factory.Create("document.pdf"); // ✅ Valid
+ // factory.Create("folder\\file.txt");          // ❌ Throws FormatException (contains path)
+ ```
+ 
+ #### `IsExtensionAttribute`
+ Validates file extensions (with period).
+ 
+ ```csharp
+ [IsExtension]
+ public sealed record FileExtension : SemanticString<FileExtension> { }
+ 
+ var factory = new SemanticStringFactory<FileExtension>();
+ var extension = factory.Create(".pdf"); // ✅ Valid
+ // factory.Create("pdf");                // ❌ Throws FormatException (no period)
+ ```
+ 
+ #### `DoesExistAttribute`
+ Validates that the path exists in the file system.
+ 
+ ```csharp
+ [IsPath, DoesExist]
+ public sealed record ExistingPath : SemanticString<ExistingPath> { }
+ 
+ var factory = new SemanticStringFactory<ExistingPath>();
+ var existingPath = factory.Create(@"C:\Windows"); // ✅ Valid (if exists)
+ // factory.Create(@"C:\NonExistent");             // ❌ Throws FormatException
+ ```
+ 
+ ### Quantity Validation
+ 
+ #### `IsPositiveAttribute`
+ Validates that numeric values are positive (> 0).
+ 
+ ```csharp
+ [IsPositive]
+ public sealed record PositiveNumber : SemanticString<PositiveNumber> { }
+ 
+ var factory = new SemanticStringFactory<PositiveNumber>();
+ var positive = factory.Create("42"); // ✅ Valid
+ // factory.Create("-5");              // ❌ Throws FormatException
+ // factory.Create("0");               // ❌ Throws FormatException
+ ```
+ 
+ #### `IsNegativeAttribute`
+ Validates that numeric values are negative (< 0).
+ 
+ ```csharp
+ [IsNegative]
+ public sealed record NegativeNumber : SemanticString<NegativeNumber> { }
+ 
+ var factory = new SemanticStringFactory<NegativeNumber>();
+ var negative = factory.Create("-42"); // ✅ Valid
+ // factory.Create("5");               // ❌ Throws FormatException
+ // factory.Create("0");               // ❌ Throws FormatException
+ ```
+ 
+ #### `IsInRangeAttribute`
+ Validates that numeric values fall within a specified range.
+ 
+ ```csharp
+ [IsInRange(1, 100)] // Between 1 and 100 inclusive
+ public sealed record Percentage : SemanticString<Percentage> { }
+ 
+ var factory = new SemanticStringFactory<Percentage>();
+ var percentage = factory.Create("75"); // ✅ Valid
+ // factory.Create("150");              // ❌ Throws FormatException
+ // factory.Create("0");                // ❌ Throws FormatException
+ ```
+ 
+ ## Built-in Types
+ 
+ The library provides pre-configured semantic string types with appropriate validations:
+ 
+ ### Path Types
+ 
+ ```csharp
+ // Pre-configured path types - no additional attributes needed
+ var pathFactory = new SemanticStringFactory<ktsu.Semantics.Path>();
+ var absoluteFactory = new SemanticStringFactory<ktsu.Semantics.AbsolutePath>();
+ var relativeFactory = new SemanticStringFactory<ktsu.Semantics.RelativePath>();
+ var fileFactory = new SemanticStringFactory<ktsu.Semantics.FilePath>();
+ var directoryFactory = new SemanticStringFactory<ktsu.Semantics.DirectoryPath>();
+ var nameFactory = new SemanticStringFactory<ktsu.Semantics.FileName>();
+ var extensionFactory = new SemanticStringFactory<ktsu.Semantics.FileExtension>();
+ 
+ // Each type has built-in validation and specialized properties
+ var filePath = fileFactory.Create(@"C:\temp\data.json");
+ Console.WriteLine(filePath.FileName);        // data.json
+ Console.WriteLine(filePath.FileExtension);   // .json
+ Console.WriteLine(filePath.DirectoryPath);   // C:\temp
+ ```
+ 
+ ## Validation Strategies
+ 
+ Control how multiple validation attributes are processed:
+ 
+ ### `ValidateAllAttribute` (Default)
+ All validation attributes must pass for the value to be considered valid.
+ 
+ ```csharp
+ [ValidateAll] // Explicit, but this is the default behavior
+ [IsNotEmpty, IsEmail, HasLength(5, 50)]
+ public sealed record StrictEmail : SemanticString<StrictEmail> { }
+ 
+ // All three validations must pass:
+ // 1. Must not be empty
+ // 2. Must be valid email format
+ // 3. Must be between 5-50 characters
+ ```
+ 
+ ### `ValidateAnyAttribute`
+ At least one validation attribute must pass for the value to be considered valid.
+ 
+ ```csharp
+ [ValidateAny]
+ [IsEmail, IsUrl]
+ public sealed record ContactInfo : SemanticString<ContactInfo> { }
+ 
+ // Either validation can pass:
+ // 1. Valid email address, OR
+ // 2. Valid URL
+ var factory = new SemanticStringFactory<ContactInfo>();
+ var email = factory.Create("user@example.com");     // ✅ Valid (email)
+ var url = factory.Create("https://example.com");    // ✅ Valid (URL)
+ ```
+ 
+ ### `ValidateWithAttribute`
+ Use a custom validation strategy for complex business rules.
+ 
+ ```csharp
+ [ValidateWith(typeof(BusinessRuleValidationStrategy))]
+ [IsNotEmpty, IsEmail] // Critical validations
+ [IsCompanyEmail, IsInternalDomain] // Non-critical validations
+ public sealed record BusinessEmail : SemanticString<BusinessEmail> { }
+ ```
+ 
+ ## Custom Validation
+ 
+ ### Creating Custom Validation Attributes
+ 
+ ```csharp
+ // Custom validation attribute
+ public class IsProductCodeAttribute : SemanticStringValidationAttribute
+ {
+     public override bool Validate(ISemanticString semanticString)
+     {
+         string value = semanticString.ToString();
+         // Product codes: letter + 5 digits
+         return Regex.IsMatch(value, @"^[A-Z][0-9]{5}$");
+     }
+ }
+ 
+ // Apply to semantic string type
+ [IsProductCode]
+ public sealed record ProductCode : SemanticString<ProductCode> { }
+ ```
+ 
+ ### Combining Multiple Validations
+ 
+ ```csharp
+ // Complex validation combining multiple attributes
+ [IsNotEmpty, IsEmail, HasLength(5, 100)]
+ public sealed record ProfessionalEmail : SemanticString<ProfessionalEmail> { }
+ 
+ // Path with existence checking
+ [IsAbsolutePath, DoesExist]
+ public sealed record ExistingAbsolutePath : SemanticPath<ExistingAbsolutePath> { }
+ 
+ // Flexible contact information
+ [ValidateAny]
+ [IsEmail, IsUrl, HasLength(10, 15)] // Email, URL, or phone number length
+ public sealed record ContactMethod : SemanticString<ContactMethod> { }
+ ```
+ 
+ This validation reference provides the foundation for creating robust, type-safe string types with comprehensive validation rules. 
```

---

Now, let me create a streamlined README that focuses on the basics and references the docs:

---

```diff
  -   **Performance**: Zero-allocation conversions and optimized operations
  -   **Comprehensive**: Full XML documentation and IntelliSense support
- 
- ## Architecture
- 
- ### SOLID Principles Implementation
- 
- The Semantics library demonstrates best practices in software architecture:
- 
- #### **Single Responsibility Principle (SRP)**
- 
- -   **Separation of Concerns**: Object creation, validation, and string operations are handled by separate classes
- -   **Factory Pattern**: `ISemanticStringFactory<T>` handles object creation logic
- -   **Validation Strategies**: Pluggable validation system with dedicated strategy classes
- 
- #### **Open/Closed Principle (OCP)**
- 
- -   **Extensible Validation**: Add new validation rules without modifying existing code
- -   **Strategy Pattern**: `IValidationStrategy` allows for custom validation approaches
- -   **Rule-Based System**: `IValidationRule` enables composable validation logic
- 
- #### **Liskov Substitution Principle (LSP)**
- 
- -   **Behavioral Contracts**: `SemanticStringContracts` ensures all implementations satisfy expected contracts
- -   **Consistent Interfaces**: All semantic string types are interchangeable through common interfaces
- 
- #### **Interface Segregation Principle (ISP)**
- 
- -   **Focused Interfaces**: Separate interfaces for different responsibilities (factory, validation, core operations)
- -   **Client-Specific Contracts**: Clients depend only on the interfaces they actually use
- 
- #### **Dependency Inversion Principle (DIP)**
- 
- -   **Abstraction-Based**: High-level modules depend on abstractions, not concrete implementations
- -   **Injected Dependencies**: Validation strategies and factories can be injected for testing and customization
- 
- ### Validation Architecture
- 
- ```csharp
- // Strategy pattern for validation approaches
- public interface IValidationStrategy
- {
-     bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value);
- }
- 
- // Extensible validation rules
- public interface IValidationRule
- {
-     string RuleName { get; }
-     bool IsApplicable(SemanticStringValidationAttribute attribute);
-     bool Validate(SemanticStringValidationAttribute attribute, ISemanticString value);
- }
- 
- // Factory pattern for object creation
- public interface ISemanticStringFactory<T> where T : ISemanticString
- {
-     T Create(string value);
-     bool TryCreate(string value, out T? result);
- }
- ```
  
  ## Quick Start
```

```diff
  // This won't compile - type safety in action!
  // SendEmail("not-an-email", subject); // Compiler error!
- ```
- 
- ### Custom Validation Strategies
- 
- ```csharp
- // Create custom validation strategies for different scenarios
- public class StrictValidationStrategy : IValidationStrategy
- {
-     public bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value)
-     {
-         // All attributes must pass (ValidateAll strategy)
-         return attributes.All(attr => attr.Validate(value));
-     }
- }
- 
- public class LenientValidationStrategy : IValidationStrategy
- {
-     public bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value)
-     {
-         // Any attribute passing is sufficient (ValidateAny strategy)
-         return attributes.Any(attr => attr.Validate(value));
-     }
- }
- 
- // Use custom validation strategies
- [ValidateWith(typeof(StrictValidationStrategy))]
- [IsEmail, IsNotEmpty]
- public sealed record StrictEmailAddress : SemanticString<StrictEmailAddress> { }
  ```
  
```

```diff
  ```
  
- ### Custom Validation Rules
+ ### Multiple Validations
  
  ```csharp
- // Create reusable validation rules
- public class ProductCodeValidationRule : ValidationRuleBase
- {
-     public override string RuleName => "ProductCode";
- 
-     protected override bool ValidateCore(SemanticStringValidationAttribute attribute, ISemanticString value)
-     {
-         string str = value.ToString();
-         // Product codes: letter + 5 digits
-         return Regex.IsMatch(str, @"^[A-Z][0-9]{5}$");
-     }
- 
-     public override bool IsApplicable(SemanticStringValidationAttribute attribute)
-         => attribute is IsProductCodeAttribute;
- }
+ // Combine multiple validation attributes
+ [IsNotEmpty, IsEmail, HasLength(5, 100)]
+ public sealed record ProfessionalEmail : SemanticString<ProfessionalEmail> { }
  
- // Custom validation attribute
- public class IsProductCodeAttribute : SemanticStringValidationAttribute
- {
-     public override bool Validate(ISemanticString semanticString)
-     {
-         var rule = new ProductCodeValidationRule();
-         return rule.Validate(this, semanticString);
-     }
- }
- 
- // Apply custom validation
- [IsProductCode]
- public sealed record ProductCode : SemanticString<ProductCode> { }
+ // Use validation strategies for complex scenarios
+ [ValidateAny]
+ [IsEmail, IsUrl]
+ public sealed record ContactInfo : SemanticString<ContactInfo> { }
  
- // Usage with automatic validation
- var factory = new SemanticStringFactory<ProductCode>();
- var validCode = factory.Create("A12345");   // ✅ Valid
- // factory.Create("123ABC");                 // ❌ Throws FormatException
+ var factory = new SemanticStringFactory<ContactInfo>();
+ var email = factory.Create("user@example.com");     // ✅ Valid (email)
+ var url = factory.Create("https://example.com");    // ✅ Valid (URL)
  ```
  
- ## Built-in Validation Attributes
- 
- The library provides comprehensive validation attributes for common scenarios:
- 
- ### String Validation
- 
- -   `IsEmailAttribute` - Email address format validation
- -   `IsUrlAttribute` - URL format validation
- -   `IsNotEmptyAttribute` - Prevents empty/null strings
- -   `HasLengthAttribute` - String length constraints
- 
- ### Path Validation
- 
- -   `IsPathAttribute` - Valid path characters and length
- -   `IsAbsolutePathAttribute` - Fully qualified paths
- -   `IsRelativePathAttribute` - Relative paths
- -   `IsFilePathAttribute` - File-specific paths
- -   `IsDirectoryPathAttribute` - Directory-specific paths
- -   `IsFileNameAttribute` - Valid filename validation
- -   `IsExtensionAttribute` - File extension validation
- -   `DoesExistAttribute` - File system existence checking
- 
- ### Quantity Validation
- 
- -   `IsPositiveAttribute` - Positive numeric values
- -   `IsNegativeAttribute` - Negative numeric values
- -   `IsInRangeAttribute` - Value range constraints
- 
- ## Built-in Types
- 
- ### Path Types
- 
- -   `Path` - Any valid path
- -   `AbsolutePath` - Fully qualified paths
- -   `RelativePath` - Relative paths
- -   `FilePath` - File paths with file operations
- -   `DirectoryPath` - Directory paths
- -   `FileName` - Just the filename component
- -   `FileExtension` - File extensions (with period)
- 
- ### String Types
- 
- -   Base `SemanticString<T>` for custom types
- -   Extensible validation system
- -   Type-safe conversions and operations
- 
- ## Advanced Features
- 
- ### Factory Pattern Usage
+ ## Documentation
+ 
+ Comprehensive documentation is available in the [`docs/`](docs/) directory:
+ 
+ - **[Architecture Guide](docs/architecture.md)** - Detailed overview of SOLID principles, design patterns, and system architecture
+ - **[Advanced Usage Guide](docs/advanced-usage.md)** - Advanced features including custom validation strategies, dependency injection, and best practices
+ - **[Validation Reference](docs/validation-reference.md)** - Complete reference of all built-in validation attributes and strategies
+ 
+ ## Common Use Cases
+ 
+ ### Domain-Specific Types
  
  ```csharp
- // Dependency injection with factories
- public class UserService
- {
-     private readonly ISemanticStringFactory<EmailAddress> _emailFactory;
-     private readonly ISemanticStringFactory<UserId> _userIdFactory;
- 
-     public UserService(
-         ISemanticStringFactory<EmailAddress> emailFactory,
-         ISemanticStringFactory<UserId> userIdFactory)
-     {
-         _emailFactory = emailFactory;
-         _userIdFactory = userIdFactory;
-     }
- 
-     public User CreateUser(string email, string id)
-     {
-         // Safe creation with automatic validation
-         var emailAddress = _emailFactory.Create(email);
-         var userId = _userIdFactory.Create(id);
-         return new User(userId, emailAddress);
-     }
- 
-     public bool TryCreateUser(string email, string id, out User? user)
-     {
-         user = null;
-         if (!_emailFactory.TryCreate(email, out var emailAddress) ||
-             !_userIdFactory.TryCreate(id, out var userId))
-         {
-             return false;
-         }
- 
-         user = new User(userId, emailAddress);
-         return true;
-     }
- }
- ```
- 
- ### Custom Validation Strategies
- 
- ```csharp
- // Implement domain-specific validation strategies
- public class BusinessRuleValidationStrategy : IValidationStrategy
- {
-     public bool Validate(IEnumerable<SemanticStringValidationAttribute> attributes, ISemanticString value)
-     {
-         // Custom business logic for validation
-         var criticalAttributes = attributes.Where(attr => attr is ICriticalValidation);
-         var nonCriticalAttributes = attributes.Except(criticalAttributes);
- 
-         // All critical validations must pass
-         bool criticalPass = criticalAttributes.All(attr => attr.Validate(value));
- 
-         // At least one non-critical validation must pass
-         bool nonCriticalPass = !nonCriticalAttributes.Any() ||
-                               nonCriticalAttributes.Any(attr => attr.Validate(value));
- 
-         return criticalPass && nonCriticalPass;
-     }
- }
- 
- // Use custom strategies with validation attributes
- [ValidateWith(typeof(BusinessRuleValidationStrategy))]
- [IsNotEmpty, IsEmail] // Critical validations
- [IsCompanyEmail, IsInternalDomain] // Non-critical validations
- public sealed record BusinessEmail : SemanticString<BusinessEmail> { }
- ```
- 
- ### Contract Validation and LSP Compliance
- 
- ```csharp
- // Ensure implementations satisfy behavioral contracts
- public class SemanticStringValidator<T> where T : SemanticString<T>
- {
-     public bool ValidateImplementation(T instance1, T instance2, T instance3)
-     {
-         // Validate basic contracts (reflexivity, symmetry, transitivity)
-         bool basicContracts = SemanticStringContracts.ValidateContracts(instance1);
- 
-         // Validate equality contracts
-         bool equalityContracts = SemanticStringContracts.ValidateEqualityContracts(instance1, instance2);
- 
-         // Validate comparison contracts (for IComparable implementations)
-         bool comparisonContracts = SemanticStringContracts.ValidateComparisonContracts(instance1, instance2, instance3);
- 
-         return basicContracts && equalityContracts && comparisonContracts;
-     }
- }
- 
- // Use in unit tests to ensure LSP compliance
- [Test]
- public void EmailAddress_ShouldSatisfySemanticStringContracts()
- {
-     var email1 = EmailAddress.FromString<EmailAddress>("user@example.com");
-     var email2 = EmailAddress.FromString<EmailAddress>("admin@example.com");
-     var email3 = EmailAddress.FromString<EmailAddress>("test@example.com");
- 
-     var validator = new SemanticStringValidator<EmailAddress>();
-     Assert.IsTrue(validator.ValidateImplementation(email1, email2, email3));
- }
- ```
- 
- ### Type Conversions
- 
- ```csharp
- // Safe conversions between compatible types
- var factory = new SemanticStringFactory<Path>();
- var genericPath = factory.Create(@"C:\temp\file.txt");
- var specificPath = genericPath.As<FilePath>(); // Convert to more specific type
- 
- // Implicit conversions to primitive types
- string pathString = specificPath;              // Implicit to string
- char[] pathChars = specificPath;               // Implicit to char[]
- ReadOnlySpan<char> pathSpan = specificPath;    // Implicit to span
- ```
- 
- ### Validation Modes
- 
- ```csharp
- // Require ALL validation attributes to pass (default)
- [ValidateAll]
- [IsPath, IsAbsolutePath, DoesExist]
- public sealed record ExistingAbsolutePath : SemanticPath<ExistingAbsolutePath> { }
- 
- // Require ANY validation attribute to pass
- [ValidateAny]
- [IsEmail, IsUrl]
- public sealed record ContactInfo : SemanticString<ContactInfo> { }
- ```
- 
- ### Path Operations
- 
- ```csharp
- var from = AbsolutePath.FromString<AbsolutePath>(@"C:\Projects\App");
- var to = AbsolutePath.FromString<AbsolutePath>(@"C:\Projects\Lib\Utils.cs");
- 
- // Create relative path between two absolute paths
- var relativePath = RelativePath.Make<RelativePath, AbsolutePath, AbsolutePath>(from, to);
- Console.WriteLine(relativePath); // ..\Lib\Utils.cs
- ```
- 
- ## Best Practices
- 
- ### SOLID and DRY Principles
- 
- 1. **Use Factory Pattern**: Prefer `ISemanticStringFactory<T>` for object creation to separate construction logic
- 2. **Implement Custom Strategies**: Create domain-specific validation strategies rather than duplicating validation logic
- 3. **Leverage Contract Validation**: Use `SemanticStringContracts` in unit tests to ensure LSP compliance
- 4. **Extend Through Interfaces**: Add new functionality through new interfaces rather than modifying existing ones
- 5. **Compose Validation Rules**: Build complex validation by composing simple, reusable `IValidationRule` implementations
- 
- ### Domain Design
- 
- 6. **Create Domain-Specific Types**: Use semantic strings for domain concepts like `UserId`, `OrderNumber`, `ProductSku`
- 7. **Validate at Boundaries**: Create semantic strings at system boundaries (APIs, user input, file I/O)
- 8. **Use Type Safety**: Let the compiler prevent string misuse with strong typing
- 9. **Combine Validations**: Use multiple validation attributes for comprehensive checking
- 10. **Document Intent**: Semantic types make code self-documenting
- 
- ### Dependency Injection
+ // Create strongly-typed identifiers
+ [HasLength(8, 12), IsNotEmpty]
+ public sealed record UserId : SemanticString<UserId> { }
+ 
+ [HasLength(3, 10), IsNotEmpty]
+ public sealed record ProductSku : SemanticString<ProductSku> { }
+ 
+ // Use them in your domain models
+ public class Order
+ {
+     public UserId CustomerId { get; set; }
+     public ProductSku[] Items { get; set; }
+ }
+ ```
+ 
+ ### Input Validation
  
  ```csharp
- // Register factories in your DI container
- services.AddTransient<ISemanticStringFactory<EmailAddress>, SemanticStringFactory<EmailAddress>>();
- services.AddTransient<ISemanticStringFactory<UserId>, SemanticStringFactory<UserId>>();
- 
- // Use in controllers/services
  public class UserController : ControllerBase
  {
```

```diff
      }
  }
+ ```
+ 
+ ### File System Operations
+ 
+ ```csharp
+ // Work with type-safe paths
+ var sourceFactory = new SemanticStringFactory<FilePath>();
+ var destinationFactory = new SemanticStringFactory<DirectoryPath>();
+ 
+ var sourceFile = sourceFactory.Create(@"C:\temp\data.csv");
+ var destinationDir = destinationFactory.Create(@"C:\backup\");
+ 
+ if (sourceFile.Exists)
+ {
+     // Type-safe file operations
+     File.Copy(sourceFile, Path.Combine(destinationDir, sourceFile.FileName));
+ }
+ ```
+ 
+ ## Built-in Validation Attributes
+ 
+ The library includes comprehensive validation for common scenarios:
+ 
+ - **String**: `IsEmail`, `IsUrl`, `IsNotEmpty`, `HasLength`
+ - **Path**: `IsPath`, `IsAbsolutePath`, `IsRelativePath`, `IsFilePath`, `IsDirectoryPath`, `DoesExist`
+ - **Numeric**: `IsPositive`, `IsNegative`, `IsInRange`
+ 
+ See the [Validation Reference](docs/validation-reference.md) for complete details.
+ 
+ ## Dependency Injection
+ 
+ ```csharp
+ // Register in your DI container
+ services.AddTransient<ISemanticStringFactory<EmailAddress>, SemanticStringFactory<EmailAddress>>();
+ services.AddTransient<ISemanticStringFactory<UserId>, SemanticStringFactory<UserId>>();
+ 
+ // Inject into services
+ public class UserService
+ {
+     private readonly ISemanticStringFactory<EmailAddress> _emailFactory;
+ 
+     public UserService(ISemanticStringFactory<EmailAddress> emailFactory)
+     {
+         _emailFactory = emailFactory;
+     }
+ }
  ```
  
```

---

Finally, let me delete the original ARCHITECTURE.md file since its content is now in the docs directory:

---

Removing the original ARCHITECTURE.md file since its content has been moved to docs/architecture.md

---

Perfect! I've successfully created a well-organized documentation structure. Here's what I accomplished:

## Summary of Changes

### ✅ Created `docs/` Directory Structure

1. **`docs/architecture.md`** - Contains all the technical architecture information from the original `ARCHITECTURE.md` file, including:
   - SOLID principles implementation
   - DRY practices
   - Design patterns (Factory, Strategy, Template Method)
   - Class hierarchy
   - Validation system architecture
   - Testing strategy

2. **`docs/advanced-usage.md`** - Contains advanced features and patterns extracted from the README:
   - Factory pattern usage with dependency injection
   - Custom validation strategies
   - Contract validation and LSP compliance
   - Type conversions
   - Validation modes
   - Path operations
   - Best practices
   - Comprehensive dependency injection examples

3. **`docs/validation-reference.md`** - Complete reference guide for validation:
   - All built-in validation attributes with examples
   - Built-in types documentation
   - Validation strategies explanation
   - Custom validation guidance
   - Multiple validation combinations

### ✅ Streamlined README.md

The README is now much more user-focused and concise:
- Kept the essential overview and key features
- Added basic usage examples
- Included common use cases with practical examples
- Added clear references to the documentation directory
- Maintained installation and quick start information
- Removed the overwhelming technical details that are now properly organized in docs

### ✅ Removed Original Files

- Deleted `ARCHITECTURE.md` since its content is now properly organized in `docs/architecture.md`

## Benefits of This Organization

1. **Better User Experience**: New users get a clean, focused README that shows them what they need to get started quickly
2. **Organized Technical Information**: Advanced users and contributors can find detailed technical information in well-structured documents
3. **Improved Maintainability**: Related documentation is grouped together, making it easier to maintain and update
4. **Clear Navigation**: Each document has a specific purpose and cross-references to related content
5. **Professional Structure**: Follows common open-source project documentation patterns

The documentation now follows a logical progression from basic usage (README) → advanced features (docs/advanced-usage.md) → deep technical details (docs/architecture.md), making it much easier for different types of users to find what they need.

---

_**User**_

can examples/README.md be renamed so its not confused with the main readme?

---

_**Assistant**_



---

I'll help you rename the examples README file to avoid confusion with the main project README. Let me first check what's in the examples directory and then rename it appropriately.

---

<details>
            <summary>Listed directory examples • **9** results</summary>
        
| Name |
|-------|
| 📄 `validation-attributes.md` |
| 📄 `real-world-scenarios.md` |
| 📄 `advanced-validation.md` |
| 📄 `factory-pattern.md` |
| 📄 `path-handling.md` |
| 📄 `string-operations.md` |
| 📄 `type-conversions.md` |
| 📄 `getting-started.md` |
| 📄 `README.md` |

</details>

---

I can see there is indeed a `README.md` file in the examples directory. Let me read its content to understand what it contains and then rename it to something more appropriate.

---

Read file: examples/README.md

---

Perfect! This is clearly an index/overview file for the examples directory. Since it serves as a navigation guide and index for the examples, I'll rename it to something more descriptive that won't be confused with the main project README. A good name would be `examples-index.md` or `examples-overview.md`.

---

```bash
cd examples && ren README.md examples-index.md
```

```
C:\dev\ktsu-dev\Semantics>cd examples && ren README.md examples-index.md

C:\dev\ktsu-dev\Semantics\examples>
```

---

Great! I've successfully renamed `examples/README.md` to `examples/examples-index.md`. This new name:

1. **Clearly identifies its purpose** - It's an index/overview of the examples
2. **Avoids confusion** - Won't be mistaken for the main project README
3. **Maintains discoverability** - The name clearly indicates it's the starting point for examples
4. **Follows naming conventions** - Uses a descriptive, hyphenated filename

The file serves as a comprehensive navigation guide for all the example files in the directory, providing:
- Quick start guidance
- Organized categories of examples
- Feature coverage checklist
- Architecture benefits explanation
- Instructions for running examples

This rename ensures that when developers see multiple README files in different directories, they can immediately understand that the main `README.md` is for the project overview while `examples/examples-index.md` is specifically for navigating the examples.

---

_**User**_

can the main readme mention the examples?

---

_**Assistant**_



---

