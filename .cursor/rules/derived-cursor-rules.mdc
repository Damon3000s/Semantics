---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new user–AI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

*   FluentValidation

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.
*   Put examples in documents, not in code.
*   **Ensure the documentation is correct.**
*   The primary problem is that the **README.md file refers to an `examples/` directory at the root level, but the examples are actually located in `docs/examples/`**. All references in `README.md` to the `examples/` directory should be updated to `docs/examples/`.
*   The architecture documentation should accurately reflect the actual class hierarchy implementation.
*   The validation reference documentation should be comprehensive and accurate, including newer validation attributes.
*   Update the `README.md` and `docs/` to describe the whole library.
*   Create a `docs/complete-library-guide.md` file to provide a comprehensive overview of all features and components in the ktsu.Semantics library.
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines.
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.
*   Remove all of the example documentation from the XML comments.
*   **Domain Implementation Workflow**
    1.  Use the Chemical domain as a template.
    2.  Before coding, search for any hard-coded constants and add them to `PhysicalConstants.cs`.
    3.  Implement quantities with full unit conversions and dimensional analysis.
    4.  Add comprehensive unit tests, including mathematical relationship checks.
    5.  Document all new quantities and constants.
*   **Always centralize physical constants** in `PhysicalConstants.cs` before using them in any domain.
*   **Use type-safe generic accessors** for all constants.
*   **Refactor any hard-coded values** found in new or existing code.
*   **Document all sources** for constants (CODATA, NIST, ISO/IEC).
*   **Follow the established code and documentation standards** (file headers, XML docs, null safety, generic constraints).
*   **Test thoroughly**: unit tests, mathematical verification, integration tests.
*   **Mechanical Domain Implementation (Highest Priority)**
    *   Implement quantities like Force, Energy, Power, Pressure, etc., with full unit conversions and dimensional analysis.
    *   Add comprehensive unit tests, including mathematical relationship checks (e.g., F = m·a, P = F/A, E = F·d).
    *   Document all new quantities and constants.
*   **Integration Tests**
    *   Create tests that use quantities from multiple domains in calculations.
    *   Verify that units and conversions work seamlessly across domains.
*   **Performance Benchmarks**
    *   Add benchmarks for common operations (e.g., unit conversions, arithmetic).
    *   Optimize as needed.
*   **Documentation Expansion**
    *   Update the `docs/complete-library-guide.md` with new domains and features.
    *   Add usage examples for new quantities.
    *   Ensure all references in `README.md` and other docs are accurate (e.g., `docs/examples/`).
*   **Implementation Plan and Tracker**
    *   **Physical Constants First**: Identify all mechanical constants needed (e.g., gravitational acceleration, standard atmospheric pressure, Planck’s constant if needed for mechanics, etc.). Add them to `PhysicalConstants.cs` under appropriate categories (Fundamental, Mechanical, etc.). Use the `PhysicalConstants.Generic` pattern for type-safe access. Include XML docs and source references (CODATA, NIST, etc.).
    *   **Define Quantities**:
        *   Location: `Quantities/Mechanics/`
        *   Quantities to Implement: Force (`Force.cs`), Pressure (`Pressure.cs`), Energy (`Energy.cs`), Power (`Power.cs`), Torque (`Torque.cs`), Momentum (`Momentum.cs`), AngularVelocity (`AngularVelocity.cs`), AngularAcceleration (`AngularAcceleration.cs`), MomentOfInertia (`MomentOfInertia.cs`), Density (`Density.cs`), SpecificGravity (`SpecificGravity.cs`), and any others listed in your TODOs. Follow the template from the Chemical domain (generic, type-safe, XML docs, unit conversions, etc.).
    *   **Units and Dimensions**: For each quantity, define the SI and common units in `Units.cs`. Add or update `PhysicalDimensions.cs` as needed for new dimensions (e.g., force, energy).
    *   **Mathematical Relationships**: Implement relationships (e.g., F = m·a, P = F/A, E = F·d) as static methods or extension methods. Add unit tests to verify these relationships using both constants and calculated values.
    *   **Testing**: For each quantity: Create unit tests for creation, conversion, and validation. Add mathematical verification tests (e.g., compare calculated force to expected value). Add edge case and error handling tests.
    *   **Documentation**: Update or create: XML docs for all new types and members. Update `docs/complete-library-guide.md` with new mechanical quantities and usage examples. Update `README.md` and any references to examples (ensure they point to `docs/examples/`).
    *   **Integration and Performance**: Create tests that use both chemical and mechanical quantities together (e.g., energy calculations involving moles and force). Add benchmarks for common operations (unit conversions, arithmetic, etc.).
    *   **Review and Refactor**: As you implement, refactor any hard-coded values found in other domains to use the new constants. Ensure all code follows the standards (headers, null safety, XML docs, etc.).
    *   **Next Domains**: After Mechanical, move to Electromagnetic, then Thermal, then Optical, Acoustic, Nuclear, and Fluid Dynamics, following the same process.
*   When a file is missing the standard header, add the following to the top of the file:
```csharp
// Copyright (c) KTSU. All rights reserved.
```
*   `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
*   `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.
*   **Implementation Process for All Domains:**
    1.  For each quantity listed in the tracker:
        *   Check if the file exists and review its implementation.
        *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
        *   If compliant, mark as implemented in the tracker.
        *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Systematic Review and Update Process for All Domains:**
    1.  **For Each Domain (Mechanical, Electrical, Thermal, etc.):**
        *   For each quantity listed in the tracker:
            *   Check if the file exists and review its implementation.
            *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
            *   If compliant, mark as implemented in the tracker.
            *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Implementation Summary**
    *   **COMPLETED DOMAINS:**
        1.  **Chemical** (10/10 quantities)
        2.  **Mechanical** (15/15 quantities)
        3.  **Electrical** (11/11 quantities)
        4.  **Thermal** (10/10 quantities)
        5.  **Acoustic** (20/20 quantities)
        6.  **Nuclear** (5/5 quantities)
        7.  **Optical** (6/6 quantities)
        8.  **Fluid Dynamics** (5/5 quantities)
    *   **REMAINING DOMAINS:**
        *   None
*   Missing friendly method alternates are not required for operators that define integral/derivative relationships, they can be suppressed with an attribute using:
```csharp
[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]
```
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation, until the formula depends on a culculation thats not in an SI base unit.
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation. Even further than that, you can use the multiply and divide operators on the PhysicalQuantity derived types directly.
*   When implementing physics relationships:
    *   Use the `.Value` property directly instead of performing unit conversions.
    *   Suppress CA2225 warnings using `[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]`.
    *   The dimensional analysis infrastructure exists in `PhysicalDimension` and base classes, but the specific physics relationships need systematic implementation across all quantity types.
    *   The current implementation lacks the fundamental integration and derivative relationships that should be expressed through `*` and `/` operators.
*   When `Force * Length` could be interpreted as energy or torque, making these calls ambiguous with the same parameters but a different return type:
    *   Keep the more fundamental relationship (work/energy) as an operator.
    *   Use an explicit method for torque.
*   When a test fails update it to use the new operator syntax instead of the removed `FromForceAndArea` method.
*   When creating PhysicalDimensions:
    *   Replace all `Units.` references in `PhysicalDimensions.cs` with the corresponding `Bootstrap` units.
*   When working with dimensionless quantities:
    *   Reserve Radians for Angular Quantities Only
    *   Create Semantically Appropriate Dimensionless Units. For example, use BootstrapDimensionless, BootstrapDecibel and BootstrapPH for non-angular dimensionless quantities.
*   **Testing Physical Constants:** Add additional tests for physical constants to validate stored values against calculated values from fundamental constants.
*   **Testing Physical Constants - Validation Chain**: Where any of the constants can be derived from fundamental constants or other derived constants, they should be tested in that fashion to make sure they are as accurate as possible through all stages of calculation.
*   **Post-Implementation Steps (All Domains Complete):**
    1.  **Documentation & Status Updates:**
        *   Update `README.md` to reflect the completed status of all domains.
        *   Update `docs/complete-library-guide.md` with details of all implemented domains.
        *   Ensure all references point to `docs/examples/` (not `examples/`).
        *   Create comprehensive usage examples for each domain.
    2.  **Code Quality & Standards Review:**
        *   Perform a systematic review to ensure all domains meet the standards:
            *   Verify all quantities use `PhysicalConstants.Generic` methods.
            *   Check for any remaining hard-coded values.
            *   Ensure all XML documentation is complete and accurate.
            *   Verify mathematical relationships are properly implemented.
            *   Standardize dimension property documentation styles. Use explicit documentation like `/// <summary>Gets the physical dimension of [quantity] [SYMBOL].</summary>` instead of `/// <inheritdoc/>`.
            *   Standardize constructor documentation styles. Use `/// <summary>Initializes a new instance of the <see cref="[ClassName]{T}"/> class.</summary>` instead of `/// Initializes a new instance of the [ClassName] class.`
    3.  **Enhanced Testing Strategy:**
        *   Building on our comprehensive physical constants tests:
            *   Integration Tests: Create tests that use quantities from multiple domains together.
            *   Performance Benchmarks: Add benchmarks for common operations.
            *   Mathematical Verification: Expand tests for physics relationships across domains.
            *   Edge Case Coverage: Ensure robust error handling.
    4.  **Performance & Optimization:**
        *   Add performance benchmarks for unit conversions and arithmetic operations.
        *   Profile memory usage and optimize if needed.
        *   Consider adding more efficient calculation paths for common operations.
    5.  **Advanced Documentation:**
        *   Create domain-specific guides with real-world examples.
        *   Add physics relationship documentation showing how quantities interact.
        *   Create migration guides for users coming from other physics libraries.
        *   Add troubleshooting and FAQ sections.
    6.  **Developer Experience Improvements:**
        *   Consider adding more convenience methods for common calculations.
        *   Implement additional operator overloads where physics relationships warrant them.
        *   Add more descriptive error messages and validation.
*   When adding new physical constants, prioritize those that are conversion factors between units.
*   **Post-Completion Enhancement Plan:**
    1.  **Code Quality & Performance Review:**
        *   Run static analysis tools to identify potential improvements.
        *   Review performance benchmarks and optimize hot paths.
        *   **Ensure all code follows consistent patterns and standards.**
    2.  **Documentation Enhancement:**
        *   Update API documentation for recent completions.
        *   Create more comprehensive examples and tutorials.
        *   Review and enhance inline XML documentation.
    3.  **Testing Strategy Enhancement:**
        *   Expand integration tests between domains.
        *   Add property-based testing for mathematical relationships.
        *   Enhance performance regression testing.
    4.  **Developer Experience Improvements:**
        *   Add more IntelliSense-friendly documentation.
        *   Create code snippets and templates.
        *   Improve error messages and diagnostics.
    5.  **Release Preparation:**
        *   Prepare for a major version bump (considering this is a significant milestone).
        *   Update release notes and documentation.
        *   Consider package optimization.
*   **Next Steps**
    *   The foundation has been established for:
        *   Completing consistency fixes across all remaining physics quantity files
        *   Implementing the advanced test suites to establish performance baselines
*   **Standardize dimension property documentation styles**. Use explicit documentation like `/// <summary>Gets the physical dimension of [quantity] [SYMBOL].</summary>` instead of `/// <inheritdoc/>`.
*   **Standardize constructor documentation styles**. Use `/// <summary>Initializes a new instance of the <see cref="[ClassName]{T}"/> class.</summary>` instead of `/// Initializes a new instance of the [ClassName] class.`
*   **Resolving Compiler Errors:** When addressing compiler errors such as CS0219 (unused variable), always analyze the context to determine if the variable should be used or removed.
*   **Physical Constants Migration:** Always ensure hardcoded constants are migrated to the `PhysicalConstants.cs` class and covered with generic getters.
*   **Missing Generic Getters in `PhysicalConstants.Generic`:**
    1.  **ElementaryCharge**
    2.  **PlanckConstant**
    3.  **BoltzmannConstant**
    4.  **FeetToMeters** (from Conversion class)
*   **Units.cs Constants Migration:**
    *   When defining units in `Units.cs`, use `PhysicalConstants.Generic` or `PhysicalConstants.Conversion` where applicable, instead of hardcoding numerical values.
*   **Units.cs Hardcoded Constants Exceptions**:
    *   Metric prefixes (handled by `MetricMagnitudes` class): `0.001`, `1000.0`, etc.
    *   Mathematical constants (like `Math.PI`): Already using C# standard library
    *   Derived unit relationships (like time conversions): `60.0` (seconds per minute), `3600.0` (seconds per hour)
    *   Imperial unit conversions not in PhysicalConstants: Many specific imperial conversions that aren't fundamental physical constants
*   **Testing Derived Constants:** Add additional tests for physical constants to validate stored values against calculated values from fundamental constants.
*   Can we put the bootstrap units in their own class so they dont pollote the PhysicalDimensions namespace?
    *   **Solution:** Create a dedicated `BootstrapUnits` class to house all bootstrap units. Refactor the `PhysicalDimensions` class to use the `BootstrapUnits` class.
*   **Multi word Tags:** Use spaces for multi word tags not hyphens