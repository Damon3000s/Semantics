---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new userâ€“AI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Include `<example>` and `<code>` blocks showing usage patterns.
*   Use `<inheritdoc/>` appropriately for interface implementations.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.

## CODING STANDARDS

(General coding standards and best practices are defined here.)

*   When using classes like `Path`, `File`, and `Directory` from `System.IO`, fully qualify the class name (e.g., `System.IO.Path`) if a `using System.IO;` statement is not present in the file.
*   When referencing methods or classes in XML documentation comments, use fully qualified names (e.g., `<see cref="System.IO.Path.IsPathFullyQualified(string)"/>`) to avoid ambiguous references.
*   Apply SOLID and DRY principles to improve code design.
*   When encountering CS0101 errors (namespace already contains a definition), and the definitions have different validation logic, rename one of the classes to avoid the conflict. Update all references to the renamed class.
*   When creating a type hierarchy, define interfaces for each level of abstraction to enable polymorphism. This includes base interfaces (e.g., `IPath`), category interfaces (e.g., `IAbsolutePath`, `IRelativePath`, `IFilePath`, `IDirectoryPath`), and composite interfaces (e.g., `IAbsoluteFilePath`, `IRelativeFilePath`, `IAbsoluteDirectoryPath`, `IRelativeDirectoryPath`). Implement these interfaces in the corresponding concrete classes.

## DEBUGGING

(Rules and guidelines for debugging are listed here.)

*   When encountering build errors, especially syntax errors reported by the compiler (e.g., CS1519, CS8124, CS1026, CS1002, CS1022), carefully examine the indicated line and surrounding code for typos, missing parentheses, semicolons, or other syntax violations.
*   When encountering CS0101 errors (namespace already contains a definition) or CS0579 errors (duplicate attribute), carefully check the indicated file for duplicate class definitions or attribute declarations.
*   If a test expects functionality that is not yet implemented, comment out or fix the test cases to align with the current implementation.
*   When resolving CS0029 errors (cannot implicitly convert type), carefully check if the type conversion is intended and whether the target type provides an implicit conversion operator. If not, explicitly access the intended property (e.g., `.Quantity`) or modify the test case accordingly.
*   When resolving CS7036 errors (no argument given that corresponds to the required parameter), ensure that all required parameters are provided in the method call. If the parameter is optional, consider providing a default value.
*   When resolving CS0019 errors (operator cannot be applied to operands of type), ensure that the operands support the specified operator. If not, explicitly access the intended property or modify the test case accordingly.
*   When debugging `IndexOfAny` or `LastIndexOfAny` methods in `SemanticStringTests`, verify that the expected index in the test case aligns with the actual index returned by the standard .NET string methods. Incorrect test expectations can lead to false positives. If the test expectation is incorrect, correct the test case to align with the actual index returned by the .NET string methods.
*   When debugging `FormatException` errors within `SemanticString<TDest>.PerformValidation` during validation strategy testing (e.g., `LongString_WithValidations_HandledCorrectly`), ensure that the input string being converted to the target type `TDest` adheres to the expected format and constraints defined by the validation logic. Pay close attention to string length, prefixes, and suffixes as defined in the validation.
    *   Specifically, when a `SemanticString<TDest>` is decorated with a `PrefixAndSuffixAttribute`, ensure that test cases use the correct prefix and suffix as defined in the attribute. A mismatch between the expected prefix/suffix in the attribute and the actual prefix/suffix in the test string will cause a `FormatException` during validation.
*   When debugging `IsPathAttribute_PathWithInvalidChars_ShouldFail` tests, be aware that `.NET` versions after `.NET Framework` may return a reduced set of invalid characters from `Path.GetInvalidPathChars()`. If the test expects characters like `<` and `>` to be invalid, ensure that the `IsPathAttribute` validation logic explicitly checks for these characters in addition to those returned by `Path.GetInvalidPathChars()`.
    *   The `IsPathAttribute` should explicitly check for characters like `<` and `>` in addition to those returned by `Path.GetInvalidPathChars()` because `.NET` versions after `.NET Framework` may return a reduced set of invalid characters from `Path.GetInvalidPathChars()`.
*   When debugging `SemanticStringTests` involving `IndexOf` or `LastIndexOf` methods, and tests are failing due to incorrect expected values, always double-check the expected values against the actual return values of the corresponding .NET string methods. The tests might have incorrect expectations.
*   When debugging `SemanticStringTests` and encountering failures in `IndexOf` and `LastIndexOf` methods, particularly in tests like `LastIndexOf_WithStringComparisonVariants_ReturnsCorrectResults`, `IndexOf_WithStartIndexVariants_ReturnsCorrectResults`, and `LastIndexOf_WithStartIndexVariants_ReturnsCorrectResults`, carefully examine the implementation of the `WeakString` class (if the `SemanticString` class delegates to it) and ensure the logic correctly handles different `StringComparison` options and `startIndex` values. If the `SemanticString` class delegates to the `WeakString` property, ensure the logic correctly handles different `StringComparison` options and `startIndex` values.
*   When `SemanticStringTests` are failing, especially for `IndexOf` and `LastIndexOf` methods, it's a high priority to:
    *   Debug and fix the `IndexOf`/`LastIndexOf` method implementations.
    *   Verify that all method overloads work correctly with their underlying `WeakString` implementations.
    *   Run the full test suite to ensure a 100% pass rate.
    *   Consider a code review of the string operation forwarding logic.
*   When debugging `IndexOf` and `LastIndexOf` methods in `SemanticStringTests`, and tests are failing, gather the following information:
    *   **Exact Test Scenarios**: Run the failing test scenarios with regular .NET strings to understand their behavior.
        ```csharp
        // Test case 1 (e.g., line 740):
        string test1 = "Hello World Hello";
        var result1 = test1.LastIndexOf("HELLO", 10, StringComparison.OrdinalIgnoreCase);
        // Record the result

        // Test case 2 (e.g., line 755):  
        string test2 = "hello world hello";
        var result2 = test2.IndexOf("hello", 5);
        // Record the result

        // Test case 3 (e.g., line 769):
        string test3 = "hello world hello"; 
        var result3 = test3.LastIndexOf("hello", 10);
        // Record the result
        ```
    *   **Test Expectations vs Reality**: Compare the expected values in the failing tests with the actual results obtained from the native string methods.
    *   **SemanticString Delegation Issue**: If `SemanticString` delegates to a `WeakString` property:
        *   Verify that the `WeakString` property is properly initialized with the correct string value.
        *   Check for any issues with named parameter delegation.
    *   **Quick Verification**: Run just the failing tests and examine the exact error output for precise method calls.
*   When debugging `IndexOf` and `LastIndexOf` methods in `SemanticStringTests`, and tests are failing with the SemanticString returning `-1` while the expected result is `0` or `12`, it indicates a delegation issue in the SemanticString class.
*   If the compiler reports CS0184 errors ("The given expression is never of the provided type") during unit testing, this indicates that the test logic is attempting to verify an impossible condition. Review the test case and adjust the assertions to align with the actual type relationships.

## WORKFLOW & RELEASE RULES

(Workflow and release rules are documented here.)

*   The main project `README.md` should mention the `examples` directory and its purpose.
*   Before releasing a version:
    *   Fix all failing tests; a 100% pass rate is required.
    *   Update the version from `1.0.0-pre.1` to `1.0.0` (or the appropriate version number).
    *   Update `CHANGELOG.md` with proper release notes.
    *   Perform final testing across different .NET versions.
    *   Conduct performance testing (if applicable).
    *   Conduct a security review of validation logic.
*   When adding new interfaces to the project, add tests to verify that the interfaces are properly implemented and that polymorphism works as expected. Consider adding the interface tests to the existing `SemanticPathTests.cs` file or creating a separate test file, depending on the existing test structure.