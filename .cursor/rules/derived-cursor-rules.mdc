---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new user–AI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

*   FluentValidation

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.
*   Put examples in documents, not in code.
*   **Ensure the documentation is correct.**
*   The primary problem is that the **README.md file refers to an `examples/` directory at the root level, but the examples are actually located in `docs/examples/`**. All references in `README.md` to the `examples/` directory should be updated to `docs/examples/`.
*   The architecture documentation should accurately reflect the actual class hierarchy implementation.
*   The validation reference documentation should be comprehensive and accurate, including newer validation attributes.
*   Update the `README.md` and `docs/` to describe the whole library.
*   Create a `docs/complete-library-guide.md` file to provide a comprehensive overview of all features and components in the ktsu.Semantics library.

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.
*   Remove all of the example documentation from the XML comments.

## CODING STANDARDS

(General coding standards and best practices are defined here.)

*   One type definition per file.
*   When using classes like `Path`, `File`, and `Directory` from `System.IO`, fully qualify the class name (e.g., `System.IO.Path`) if a `using System.IO;` statement is not present in the file.
*   When referencing methods or classes in XML documentation comments, use fully qualified names (e.g., `<see cref="System.IO.Path.IsPathFullyQualified(string)"/>`) to avoid ambiguous references.
*   Apply SOLID and DRY principles to improve code design.
*   When encountering CS0101 errors (namespace already contains a definition), and the definitions have different validation logic, rename one of the classes to avoid the conflict. Update all references to the renamed class.
*   When creating a type hierarchy, define interfaces for each level of abstraction to enable polymorphism. This includes base interfaces (e.g., `IPath`), category interfaces (e.g., `IAbsolutePath`, `IRelativePath`, `IFilePath`, `IDirectoryPath`), and composite interfaces (e.g., `IAbsoluteFilePath`, `IRelativeFilePath`, `IAbsoluteDirectoryPath`, `IRelativeDirectoryPath`). Implement these interfaces in the corresponding concrete classes.
*   All directory paths should have a public property called `Contents` that gets the files and directories in that directory as the appropriate semantic path types.
*   When using interface types in string operations (e.g., with `System.IO.Path` methods or string concatenation), cast the interface to its concrete type and call the `ToString()` method explicitly. For example: `Path.Combine(((DirectoryPath)directoryPath).ToString(), ((FileName)fileName).ToString())`.
*   When concatenating a string with the result of `ToString()` on a semantic type, use null protection to avoid potential null reference exceptions. For example: `"prefix_" + (path.ToString() ?? string.Empty)`.
*   Semantic paths support file system existence checking properties: `Exists` (true if the path exists as either a file or directory), `IsDirectory` (true if the path exists as a directory), and `IsFile` (true if the path exists as a file.
*   Semantic paths support implicit conversion to system strings, allowing them to be transparently passed in place of string parameters.
*   Semantic strings support implicit conversion to `string`, `char[]`, and `ReadOnlySpan<char>`.
*   When using interface types for semantic paths (e.g., `IAbsolutePath`, `IFilePath`), the implicit string conversion does not work. In these cases, you must either:
    *   Cast the interface to its concrete type and call `ToString()`.
    *   Call `ToString()` explicitly on the interface type.
*   Implement the `/` operator for all the semantic path types where it makes sense, and make it return the correct type. The operator should allow combining directory paths with relative paths to create new paths. Consider the following combinations:
    1.  `AbsoluteDirectoryPath` + `RelativeDirectoryPath` → `AbsoluteDirectoryPath`
    2.  `AbsoluteDirectoryPath` + `RelativeFilePath` → `AbsoluteFilePath`
    3.  `RelativeDirectoryPath` + `RelativeDirectoryDirectoryPath` → `RelativeDirectoryDirectoryPath`
    4.  `RelativeDirectoryPath` + `RelativeFilePath` → `RelativeFilePath`
    5.  Similar combinations for the base `DirectoryPath` types
*   When the linter complains about missing `Divide` methods, don't add them. Instead, silence the error with a `SuppressMessage` attribute. The `SuppressMessage` attribute should use the following justification: `"Path combination is the semantic meaning, not mathematical division"`.
*   Add methods to the semantic path types to get filename, file extension, directory etc from the appropriate types.
*   For `AbsoluteFilePath` and `RelativeFilePath`, add a property that returns the directory portion of the path as the correctly typed directory path (`AbsoluteDirectoryPath` or `RelativeDirectoryPath`, respectively). This property should be named after the return type:
    *   `AbsoluteFilePath.AbsoluteDirectoryPath`
    *   `RelativeFilePath.RelativeDirectoryPath`
*   For `DirectoryPath`, `AbsoluteDirectoryPath`, and `RelativeDirectoryPath`, add the following properties:
    *   `Parent`: Gets the parent directory of this directory path as the correct semantic type.
    *   `Name`: Gets the name of this directory (the last component of the path) as a `FileName`.
*   For `AbsoluteFilePath` and `RelativeFilePath`:
    *   `FileNameWithoutExtension` - Gets just the filename without extension
    *   `ChangeExtension(FileExtension)` - Changes the file extension
    *   `RemoveExtension()` - Removes the file extension
    *   `IsChildOf(AbsoluteDirectoryPath)` - Checks if the file is within a directory
    *   `AbsoluteDirectoryPath` - Gets the directory as `AbsoluteDirectoryPath`.
*   For `RelativeFilePath`:
    *   `ToAbsolute(AbsoluteDirectoryPath)` - Converts relative to absolute path
    *   `RelativeDirectoryPath` - Gets the directory as `RelativeDirectoryPath`.
*   For `AbsoluteDirectoryPath`:
    *   `IsParentOf(AbsoluteFilePath/AbsoluteDirectoryPath)` - Checks parent-child relationships
    *   `IsChildOf(AbsoluteDirectoryPath)` - Checks if this is a child of another directory
    *   `Depth` - Gets the depth from root (0 for root directories)
    *   `GetAncestors()` - Gets all parent directories up to root
    *   `IsRoot` - Determines if this is a root directory
    *   `GetRelativePathTo(AbsoluteDirectoryPath)` - Creates relative path to another directory
*   For `RelativeDirectoryPath`:
    *   `Parent` - Gets the parent directory (appropriately typed)
    *   `Name` - Gets the directory name
    *   `Depth` - Gets the relative depth (number of directory levels)
    *   `ToAbsolute(AbsoluteDirectoryPath)` - Converts to absolute path using a base
    *   `Normalize()` - Normalizes the path by resolving `.` and `..` components
*   For the path hierarchy interfaces:
    *   `AsAbsoluteFilePath()` - Converts to `AbsoluteFilePath`
    *   `AsRelativeFilePath()` - Converts to `RelativeFilePath`
    *   `AsAbsoluteDirectoryPath()` - Converts to `AbsoluteDirectoryPath`
    *   `AsRelativeDirectoryPath()` - Converts to `RelativeDirectoryPath`
*   Consider caching expensive property computations such as `Path.GetDirectoryName` and `Path.GetFileNameWithoutExtension`. Use lazy initialization with the `??=` operator and private backing fields.
*   When implementing `IsChildOf` and `IsParentOf` methods:
    *   Cache full paths to avoid repeated `Path.GetFullPath` calls.
    *   Ensure the parent path ends with a directory separator for accurate comparison using `StartsWith`.
    *   Use `StringComparison.OrdinalIgnoreCase` for case-insensitive comparisons.
*   String Interning for Common Paths - Intern frequently used directory separators and common path roots
*   ReadOnlySpan\<char> Usage - Use spans for path parsing to reduce allocations
*   Pooled StringBuilder - For path combination operations
*   Async Directory Enumeration - For Contents property with large directories
*   Use span semantics instead of suffixing with "Span". Instead, use method overloading to provide span-based alternatives.
*   Use ReadOnlySpan overloads instead of creating methods with a Span suffix. If the signature overlaps with existing methods, the return type can be different.
*   When using implicit operators to convert to `ReadOnlySpan<char>`, use `value is null ? default : value.AsSpan()` instead of `value?.AsSpan() ?? default`.
*   When calculating directory `Depth`, the value is the number of directory separators in the path.
*   When implementing `IsChildOf` and `IsParentOf` methods:
    *   Cache full paths to avoid repeated `Path.GetFullPath` calls
    *   Ensure the parent path ends with a directory separator for accurate comparison using `StartsWith`.
    *   Use `StringComparison.OrdinalIgnoreCase` for case-insensitive comparisons.
*   For performance, replace `ToString()` calls with `WeakString` where appropriate.
*   For `IsChildOf()` and `IsParentOf()` methods, use span-based comparison for better performance than string concatenation. Normalize both paths before comparison to handle different separator styles.
*   When the signatures of existing methods overlap with span-based versions, use method overloading to provide span-based alternatives. If the signatures do not overlap, use different method names.
*   For the `Depth` property, the value is the number of directory separators in the path.
*   One type definition per file.
*   For ease of use, use a single common namespace for all types in the library.
*   SemanticStringValidationExamples can just be built in semantic types where appropriate
*   If the signatures of existing methods overlap with span-based versions, use method overloading to provide span-based alternatives. If the signatures do not overlap, use different method names.
*   The built in semantic string types should not need the string suffix.
*   For the implicit `ReadOnlySpan<char>` operator, use `value is null ? default : value.AsSpan()` instead of `value?.AsSpan() ?? default`.
*   When calculating directory `Depth`, the value is the number of directory separators in the path.
*   The built in semantic string types are either too niche or too simple, create a collection of useful builtin semantic string types with appropriate validations, where they aren't already implemented in dotnet, like Uri is.
*   Validation attributes should be separated into their own files.
*   Instead of creating generic built-in types like `Base64String`, use validation attributes like `[IsBase64]`, `[IsGuid]`, `[IsEmailAddress]` etc. that can be applied to domain-specific semantic string types. This is much more flexible and composable.
*   Validation attributes for different string casing types should be created, including title, pascal, kebab, snake, camel, macro, upper, lower, and sentence casing. These should be placed in a dedicated subdirectory for casing-related attributes: `Semantics/Validation/Attributes/Casing/`.
*   These are excellent advanced performance optimization suggestions:
    *   String Interning for Common Paths - Intern frequently used directory separators and common path roots
    *   ReadOnlySpan\<char> Usage - Use spans for path parsing to reduce allocations
    *   Pooled StringBuilder - For path combination operations
    *   Async Directory Enumeration - For Contents property with large directories
*   If there is already a first class type in .NET (e.g. `IPAddress`, `Version`, `Guid`), then the validator should direct users to use the first class type instead.
*   Validators that represent types that have first-class representations in dotnet already should provide accurate validation, but be listed as obsolete, prompting users to use the first class types.
*   Validators that represent types that have first-class representations in dotnet already should provide accurate validation, but be listed as obsolete, prompting users to use the first class types.
    *   `IsVersionAttribute` - Now marked as obsolete, encouraging users to use `System.Version` instead of semantic string types, highlighting the broader benefits
    *   `IsGuidAttribute` - Now marked as obsolete, encouraging users to use `System.Guid` instead of semantic string types, emphasizing type safety and efficiency
    *   `IsIpAddressAttribute` - Now suggests using `System.Net.IPAddress` instead of semantic string types, focusing on the comprehensive network API
    *   `IsDateTimeAttribute` - Now marked as obsolete, encouraging users to use `System.DateTime` instead of semantic string types, highlighting the broader benefits
    *   `IsTimeSpanAttribute` - Now marked as obsolete, encouraging users to use `System.TimeSpan` instead of semantic string types, highlighting the broader benefits
    *   `IsUriAttribute` - Now suggests using `System.Uri` instead of semantic string types, focusing on the comprehensive network API
    *   `IsDecimalAttribute` - Now suggests using `System.DecimalAttribute` instead of semantic string types, focusing on the comprehensive mathematical API
    *   `IsDoubleAttribute` - Now suggests using `System.DoubleAttribute` instead of semantic string types, focusing on the comprehensive mathematical API
    *   `IsInt32Attribute` - Now suggests using `System.Int32Attribute` instead of semantic string types, focusing on the comprehensive numerical API
    *   `IsBooleanAttribute` - Now suggests using `System.BooleanAttribute` instead of semantic string types, focusing on the comprehensive logical API
*   Use the FluentValidation library to implement the internals of the validation attributes where possible.
*   Provide feature parity between direct static methods and factory methods so users can choose their preferred pattern without losing functionality.
*   Use overloading with a more communicative common name for `From` and `TryFrom` methods instead of specifically type named variants.
*   When migrating the physical quantity functionality into the semantics library:
    *   The PhysicalQuantity library has:
        *   31+ physical quantity types (Length, Mass, Time, Energy, Velocity, etc.)
        *   A sophisticated base class `PhysicalQuantity<TSelf>` that extends `SemanticQuantity<TSelf, StorageType>`
        *   SI unit attributes for metadata (symbol, singular/plural names)
        *   Extension methods for unit conversions
        *   Integral and derivative operator interfaces for physical relationships
        *   Comprehensive conversion constants
    *   Create an attribute to define the SI unit for a class.
    *   Define an interface for integral operations between physical quantities.
    *   Define an interface for derivative operations between physical quantities.
    *   Provide conversion factors for various physical quantities and metric prefixes.
    *   Represent a physical quantity with a specific unit of measurement.
    *   Provide static methods for converting values to and from physical quantities.
*   When defining properties in `PhysicalQuantity` classes that override base class properties, ensure the types match exactly. For example, `Acceleration.Dimension` should be of type `PhysicalDimension` to match the overridden member `PhysicalQuantity<Acceleration, double>.Dimension`.
*   When defining `PhysicalQuantity` classes:
    *   Ensure the class is non-abstract and has a public parameterless constructor.
    *   Include XML documentation comments for all constructs.
    *   Avoid throwing exceptions from methods not expected to throw them.
    *   Ensure the base class `PhysicalQuantity<TSelf>` has a constructor that takes the required arguments.
    *   Ensure that all required methods and properties (e.g., `ConvertToUnit`, `Unit`) are defined or accessible in the current context.
    *   Ensure that all reference arguments are non-null by using `ArgumentNullException.ThrowIfNull()` if necessary.
*   When defining `PhysicalQuantity` classes, the correct pattern is:
    ```csharp
    public override PhysicalDimension Dimension => PhysicalDimensions.SomeDimension;
    public ClassName() : base() { }
    // Uses inherited Create(double value) method automatically
    ```
*   `PhysicalDimensionExtensions.cs` extensions should be to the `INumber` interface, rather than to all of the concrete types.
*   When creating extension methods for Physical Quantities:
    *   Use generic `INumber<T>` extensions instead of concrete type overloads. This will make the code more maintainable and work with all numeric types.
    *   Use `T.CreateChecked()` for conversion factors instead of hardcoded doubles
    *   Maintain original conversion logic and factors.
    *   Add proper XML documentation with `<typeparam>` tags.
    *   For PhysicalQuantity extension methods that use units, and thus the `Create(value, Units.SomeUnit)` syntax, remove the methods entirely.
    *   Eliminate backward compatibility methods that duplicate functionality.
*   When integrating the unit classes with `PhysicalDimensionExtensions`, conversion factors should be defined only once in the `Units` class. All conversions should use the same authoritative source, ensuring consistency and maintainability. This eliminates duplication and enables extensibility and type safety.
*   Eliminate the code that implements concrete storage types for quantities and only support the generics. Non-generic overloads can be added later where appropriate.
*   `PhysicalQuantity` represents an actual measured value:
    *   It combines a numerical value with dimensional information
    *   It provides the behavior for quantities (comparison, arithmetic, unit conversion)
    *   It's an abstract base class that specific quantities inherit from
    *   It includes business logic like `IsPhysicallyValid`, `In()` method for conversions, etc.
*   `PhysicalDimension` represents the dimensional analysis aspect:
    *   It's a mathematical concept that describes what type of measurement something is
    *   It stores the powers of the 7 fundamental SI base units (length, mass, time, etc.)
    *   It enables dimensional analysis (e.g., Force = M L T⁻²)
    *   It's used for compile-time safety and unit conversion validation
    *   It's a struct that's immutable and lightweight
*   The relationship between `PhysicalQuantity` and `PhysicalDimension` is compositional, not identical: `PhysicalQuantity` **HAS-A** `PhysicalDimension`, it **IS-NOT-A** `PhysicalDimension`. This is a classic composition relationship where the quantity uses the dimension for validation and type safety.
*   Do not merge `PhysicalQuantity` and `PhysicalDimension`. Keeping them separate is beneficial because:
    1.  Single Responsibility: `PhysicalDimension` handles dimensional math, `PhysicalQuantity` handles value storage and behavior
    2.  Reusability: Multiple quantity types can share the same dimension (e.g., Energy and Torque both have dimension M L² T⁻²)
    3.  Performance: `PhysicalDimension` is a lightweight struct optimized for dimensional calculations
    4.  Type Safety: The current design provides excellent compile-time checking
    5.  Clarity: The separation makes the code's intent much clearer
*   `BaseUnit` is a property of the dimension, not the quantity.
*   For any given dimension, there's exactly one SI base unit.
*   It's repetitive and error-prone for every quantity class to have to manually specify the same BaseUnit for the same dimension.
*   The dimension should know its own base unit:
    ```csharp
    // In PhysicalDimension
    public IUnit BaseUnit => GetBaseUnitForDimension(this);

    // Or stored as static lookup
    public static IUnit GetBaseUnit(PhysicalDimension dimension) => dimension switch
    {
        var d when d == PhysicalDimensions.Force => Units.Newton,
        var d when d == PhysicalDimensions.Energy => Units.Joule,
        var d when d == PhysicalDimensions.Length => Units.Meter,
        // etc...
    };
    ```
*   Unit validation logic could be a method on `PhysicalDimension`:
    ```csharp
    // In PhysicalDimension
    public bool IsCompatibleWith(IUnit unit) => this.Equals(unit.Dimension);
    public void ValidateUnitCompatibility(IUnit unit) => /* validation logic */
    ```
*   The following should stay in `PhysicalQuantity`:
    *   Value storage and retrieval
    *   Arithmetic operations
    *   Comparison logic
    *   `IsPhysicallyValid` (this is about the specific value, not the dimension)
    *   `In()` conversion method (this operates on the value using dimensional info)
*   When refactoring `PhysicalQuantity` and `PhysicalDimension`:
    1.  Pass the base unit directly to the `PhysicalDimension` constructor.
    2.  Remove the `BaseUnit` property from `PhysicalQuantity` and its interface.
    3.  Update `PhysicalQuantity.In()` to use `Dimension.BaseUnit`.

## DEBUGGING

(Rules and guidelines for debugging are listed here.)

*   When encountering build errors, especially syntax errors reported by the compiler (e.g., CS1519, CS8124, CS1026, CS1002, CS1022), carefully examine the indicated line and surrounding code for typos, missing parentheses, semicolons, or other syntax violations.
*   When encountering CS0101 errors (namespace already contains a definition) or CS0579 errors (duplicate attribute), carefully check the indicated file for duplicate class definitions or attribute declarations.
*   If a test expects functionality that is not yet implemented, comment out or fix the test cases to align with the current implementation.
*   When resolving CS0029 errors (cannot implicitly convert type), carefully check if the type conversion is intended and whether the target type provides an implicit conversion operator. If not, explicitly access the intended property (e.g., `.Quantity`) or modify the test case accordingly.
*   When resolving CS7036 errors (no argument given that corresponds to the required parameter), ensure that all required parameters are provided in the method call. If the parameter is optional, consider providing a default value.
*   When resolving CS0019 errors (operator cannot be applied to operands of type), ensure that the operands support the specified operator. If not, explicitly access the intended property or modify the test case accordingly.
*   When debugging `IndexOfAny` or `LastIndexOfAny` methods in `SemanticStringTests`, verify that the expected index in the test case aligns with the actual index returned by the standard .NET string methods. Incorrect test expectations can lead to false positives. If the test expectation is incorrect, correct the test case to align with the actual index returned by the .NET string methods.
*   When debugging `FormatException` errors within `SemanticString<TDest>.PerformValidation` during validation strategy testing (e.g., `LongString_WithValidations_HandledCorrectly`), ensure that the input string being converted to the target type `TDest` adheres to the expected format and constraints defined by the validation logic. Pay close attention to string length, prefixes, and suffixes as defined in the validation.
    *   Specifically, when a `SemanticString<TDest>` is decorated with a `PrefixAndSuffixAttribute`, ensure that test cases use the correct prefix and suffix as defined in the attribute. A mismatch between the expected prefix/suffix in the attribute and the actual prefix/suffix in the test string will cause a `FormatException` during validation.
*   When debugging `IsPathAttribute_PathWithInvalidChars_ShouldFail` tests, be aware that `.NET` versions after `.NET Framework` may return a reduced set of invalid characters from `Path.GetInvalidPathChars()`. If the test expects characters like `<` and `>` to be invalid, ensure that the `IsPathAttribute` validation logic explicitly checks for these characters in addition to those returned by `Path.GetInvalidPathChars()`.
    *   The `IsPathAttribute` should explicitly check for characters like `<` and `>` in addition to those returned by `Path.GetInvalidPathChars()` because `.NET` versions after `.NET Framework` may return a reduced set of invalid characters from `Path.GetInvalidPathChars()`.
*   When debugging `SemanticStringTests` involving `IndexOf` or `LastIndexOf` methods, and tests are failing due to incorrect expected values, always double-check the expected values against the actual return values of the corresponding .NET string methods. The tests might have incorrect expectations.
*   When debugging `SemanticStringTests` and encountering failures in `IndexOf` and `LastIndexOf` methods, particularly in tests like `LastIndexOf_WithStringComparisonVariants_ReturnsCorrectResults`, `IndexOf_WithStartIndexVariants_ReturnsCorrectResults`, and `LastIndexOf_WithStartIndexVariants_ReturnsCorrectResults`, carefully examine the implementation of the `WeakString` class (if the `SemanticString` class delegates to it) and ensure the logic correctly handles different `StringComparison` options and `startIndex` values. If the `SemanticString` class delegates to the `WeakString` property, ensure the logic correctly handles different `StringComparison` options and `startIndex` values.
*   When `SemanticStringTests` are failing, especially for `IndexOf` and `LastIndexOf` methods, it's a high priority to:
    *   Debug and fix the `IndexOf`/`LastIndexOf` method implementations.
    *   Verify that all method overloads work correctly with their underlying `WeakString` implementations.
    *   Run the full test suite to ensure a 100% pass rate.
    *   Consider a code review of the string operation forwarding logic.
*   When debugging `IndexOf` and `LastIndexOf` methods in `SemanticStringTests`, and tests are failing, gather the following information:
    *   **Exact Test Scenarios**: Run the failing test scenarios with regular .NET strings to understand their behavior.
        ```csharp
        // Test case 1 (e.g., line 740):
        string test1 = "Hello World Hello";
        var result1 = test1.LastIndexOf("HELLO", 10, StringComparison.OrdinalIgnoreCase);
        // Record the result

        // Test case 2 (e.g., line 755):  
        string test2 = "hello world hello";
        var result2 = test2.IndexOf("hello", 5);
        // Record the result

        // Test case 3 (e.g., line 769):
        string test3 = "hello world hello"; 
        var result3 = test3.LastIndexOf("hello", 10);
        // Record the result
        ```
    *   **Test Expectations vs Reality**: Compare the expected values in the failing tests with the actual results obtained from the native string methods.
    *   **SemanticString Delegation Issue**: If `SemanticString` delegates to a `WeakString` property:
        *   Verify that the `WeakString` property is properly initialized with the correct string value.
        *   Check for any issues with named parameter delegation.
    *   **Quick Verification**: Run just the failing tests and examine the exact error output for precise method calls.
*   When debugging `IndexOf` and `LastIndexOf` methods in `SemanticStringTests`, and tests are failing with the SemanticString returning `-1` while the expected result is `0` or `12`, it indicates a delegation issue in the SemanticString class.
*   If the compiler reports CS0184 errors ("The given expression is never of the provided type") during unit testing, this indicates that the test logic is attempting to verify an impossible condition. Review the test case and adjust the assertions to align with the actual type relationships.
*   When resolving CS1503 errors (Argument cannot convert from type X to type Y), carefully examine the method signature and the types of the arguments being passed. Ensure that the arguments are of the correct type or can be implicitly converted to the expected type. Review the relevant interfaces and classes to ensure they are being used correctly.
*   When resolving CA1859 errors (Change type of variable 'variableName' from 'InterfaceName' to 'ClassName' for improved performance), consider changing the variable type as suggested by the analyzer to improve performance.
*   If a `CS8600` error ("Converting null literal or possible null value to non-nullable type") persists despite null-checking and handling, review the project's nullable reference types configuration and ensure it aligns with the intended behavior. The error might be a false positive or require project-specific adjustments.
*   When debugging `FormatException` errors originating from `SemanticString<TDest>.PerformValidation`, especially during `RelativeDirectoryPath_Contents_ReturnsRelativePathTypes`, `SemanticPath_PathTypes`, or `SemanticPath_MakeCanonical_WithMixedSeparators_ShouldNormalize` tests, carefully review the validation logic and ensure that the input string adheres to the expected format for the target type `TDest`. Pay close attention to the following:
    *   **Relative vs. Absolute Paths**: Ensure that the input string matches the expected type (e.g., `RelativeDirectoryPath` should not start with a root directory).
    *   **Path Separators**: Verify that the path separators are consistent and correctly normalized (if normalization is expected).
    *   **Invalid Characters**: Ensure that the path does not contain any invalid characters or sequences.
*   When a test expects `System.ArgumentException` but gets `System.FormatException`, it indicates that the validation logic is throwing a `FormatException` when it should be throwing an `ArgumentException`. Review the validation logic and update it to throw the correct exception type based on the nature of the error. For example, if the error is due to an invalid argument value, throw `ArgumentException`; if it's due to an invalid format, throw `FormatException`.
*   When debugging `RelativeDirectoryPath_Contents_ReturnsRelativePathTypes` test failures, ensure that the test uses `AbsoluteDirectoryPath` instances when testing contents of absolute directory paths. Ensure there are no tab characters in the test file.
*   When debugging `SemanticPath_RootPath_Unix` test failures, ensure that path canonicalization correctly handles Unix root paths ("/") and doesn't convert them to Windows path separators ("\\").
*   When debugging `SemanticPath_PathTypes` test failures, ensure that the correct path type (e.g., `AbsolutePath`, `RelativePath`) is used in the test case based on whether the path is absolute or relative.
*   When debugging `SemanticPath_PathLength_TooLong` tests, be aware that the validation logic throws `FormatException` for path length violations. The tests should expect `FormatException`.
*   When debugging `IndexOf` and `LastIndexOf` methods, and tests are failing, it's important to check the following:
    *   Verify that all method overloads work correctly with their underlying `WeakString` implementations.
    *   Verify that the `WeakString` property is properly initialized with the correct string value.
    *   Check for any issues with named parameter delegation.
*   When debugging `SpanPathUtilities.GetFileName` and encountering failing tests with trailing separators, ensure that the method returns an empty span when the path ends with a directory separator.
*   When encountering CS0122 errors related to `SemanticString<T>.FromString<TDest>(string?)` being inaccessible, replace all calls to `FromString<TDest>` with `Create<TDest>`.
*   When encountering CS1715 errors (type must be 'PhysicalDimension' to match overridden member), ensure that the type of the overriding property or member matches the type of the overridden property or member in the base class.
*   When encountering CA1032 errors in `UnitConversionException.cs` (Failure to provide the full set of constructors), ensure that the exception class provides all the standard exception constructors.
*   When encountering CS8862 errors in `UnitConversionException.cs` (A constructor declared in a type with parameter list must have 'this' constructor initializer), ensure that constructors with parameters call the primary constructor using `this(...)`.
*   When encountering CA1062 errors in `UnitExtensions.cs` (An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null'), add null checks (e.g., `ArgumentNullException.ThrowIfNull()`) for all reference arguments in externally visible methods.
*   When encountering CS1591 errors (The /doc compiler option was specified, but one or more constructs did not have comments), add XML documentation comments to all public types and members.
*   When encountering CA1502 errors, refactor the code to decrease its complexity.
*   When encountering CS1503 errors (Argument 1: cannot convert from 'int' to 'ktsu.Semantics.IUnit') in `PhysicalDimension.cs` during operator overloading, ensure that the constructor calls include the required `IUnit` parameter with a proper base unit.

## WORKFLOW & RELEASE RULES

(Workflow and release rules are documented here.)

*   The main project `README.md` should mention the `examples` directory and its purpose.
*   Before releasing a version:
    *   Fix all failing tests; a 100% pass rate is required.
    *   Update the version from `1.0.0-pre.1` to `1.0.0` (or the appropriate version number).
    *   Update `CHANGELOG.md` with proper release notes.
    *   Perform final testing across different .NET versions.
    *   Conduct performance testing (if applicable).
    *   Conduct a security review of validation logic.
*   When adding new interfaces to the project, add tests to verify that the interfaces are properly implemented and that polymorphism works as expected. Consider adding the interface tests to the existing `SemanticPathTests.cs` file or creating a separate test file, depending on the existing test structure.
*   Determine if interfaces can implicitly cast to system strings so that they can be passed transparently where strings are normally used.
*   Split out the non-trivial types from files with multiple types in them
*   When calculating directory `Depth`, the value is the number of directory separators in the path.
*   For ease of use, use a single common namespace for all types in the library.
*   SemanticStringValidationExamples can just be built in semantic types where appropriate
*   The built in semantic string types should not need the string suffix.
*   Instead of creating generic built-in types like `Base64String`, use validation attributes like `[IsBase64]`, `[IsGuid]`, `[IsEmailAddress]` etc. that can be applied to domain-specific semantic string types.
*   Validation attributes should be separated into their own files.
*   Instead of creating generic built-in types like `Base6String`, use validation attributes like `[IsBase64]`, `[IsGuid]`, `[IsEmailAddress]` etc. that can be applied to domain-specific semantic string types.
*   The built in semantic string types are too niche or too simple, create a collection of useful builtin semantic string types with appropriate validations, where they aren't already implemented in dotnet, like Uri is.
*   Validation attributes should be separated into their own files.
*   Instead of creating generic built-in types like `Base64String`, use validation attributes like `[IsBase64]`, `[IsGuid]`, `[IsEmailAddress]` etc. that can be applied to domain-specific semantic string types.
*   **When implementing PhysicalQuantity classes, ensure the containing type is one of the parameters in the generic type definition.**

## QUANTITIES IMPLEMENTATION STRATEGY

### Current Implementation Status

*   **Mechanics**: Partially implemented (11/18 quantities).
*   **Electrical**: Partially implemented (5/11 quantities).
*   **Acoustic**: Partially implemented (1/20+ quantities).
*   **Thermal**: Not implemented (0/10 quantities).
*   **Chemical**: Not implemented (0/17 quantities).
*   **Optical**: Not implemented (0/18 quantities).

### Priority Implementation Tasks

1.  **Complete Mechanics Domain** (7 missing quantities):
    *   `Momentum.cs` - p = mv
    *   `AngularVelocity.cs` - Rotational motion
    *