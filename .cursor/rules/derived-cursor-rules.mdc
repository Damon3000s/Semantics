---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new user–AI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

*   FluentValidation

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.
*   Put examples in documents, not in code.
*   **Ensure the documentation is correct.**
*   The primary problem is that the **README.md file refers to an `examples/` directory at the root level, but the examples are actually located in `docs/examples/`**. All references in `README.md` to the `examples/` directory should be updated to `docs/examples/`.
*   The architecture documentation should accurately reflect the actual class hierarchy implementation.
*   The validation reference documentation should be comprehensive and accurate, including newer validation attributes.
*   Update the `README.md` and `docs/` to describe the whole library.
*   Create a `docs/complete-library-guide.md` file to provide a comprehensive overview of all features and components in the ktsu.Semantics library.
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines.
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.
*   Remove all of the example documentation from the XML comments.
*   **Domain Implementation Workflow**
    1.  Use the Chemical domain as a template.
    2.  Before coding, search for any hard-coded constants and add them to `PhysicalConstants.cs`.
    3.  Implement quantities with full unit conversions and dimensional analysis.
    4.  Add comprehensive unit tests, including mathematical relationship checks.
    5.  Document all new quantities and constants.
*   **Always centralize physical constants** in `PhysicalConstants.cs` before using them in any domain.
*   **Use type-safe generic accessors** for all constants.
*   **Refactor any hard-coded values** found in new or existing code.
*   **Document all sources** for constants (CODATA, NIST, ISO/IEC).
*   **Follow the established code and documentation standards** (file headers, XML docs, null safety, generic constraints).
*   **Test thoroughly**: unit tests, mathematical verification, integration tests.
*   **Mechanical Domain Implementation (Highest Priority)**
    *   Implement quantities like Force, Energy, Power, Pressure, etc., with full unit conversions and dimensional analysis.
    *   Add comprehensive unit tests, including mathematical relationship checks (e.g., F = m·a, P = F/A, E = F·d).
    *   Document all new quantities and constants.
*   **Integration Tests**
    *   Create tests that use quantities from multiple domains in calculations.
    *   Verify that units and conversions work seamlessly across domains.
*   **Performance Benchmarks**
    *   Add benchmarks for common operations (e.g., unit conversions, arithmetic).
    *   Optimize as needed.
*   **Documentation Expansion**
    *   Update the `docs/complete-library-guide.md` with new domains and features.
    *   Add usage examples for new quantities.
    *   Ensure all references in `README.md` and other docs are accurate (e.g., `docs/examples/`).
*   **Implementation Plan and Tracker**
    *   **Physical Constants First**: Identify all mechanical constants needed (e.g., gravitational acceleration, standard atmospheric pressure, Planck’s constant if needed for mechanics, etc.). Add them to `PhysicalConstants.cs` under appropriate categories (Fundamental, Mechanical, etc.). Use the `PhysicalConstants.Generic` pattern for type-safe access. Include XML docs and source references (CODATA, NIST, etc.).
    *   **Define Quantities**:
        *   Location: `Quantities/Mechanics/`
        *   Quantities to Implement: Force (`Force.cs`), Pressure (`Pressure.cs`), Energy (`Energy.cs`), Power (`Power.cs`), Torque (`Torque.cs`), Momentum (`Momentum.cs`), AngularVelocity (`AngularVelocity.cs`), AngularAcceleration (`AngularAcceleration.cs`), MomentOfInertia (`MomentOfInertia.cs`), Density (`Density.cs`), SpecificGravity (`SpecificGravity.cs`), and any others listed in your TODOs. Follow the template from the Chemical domain (generic, type-safe, XML docs, unit conversions, etc.).
    *   **Units and Dimensions**: For each quantity, define the SI and common units in `Units.cs`. Add or update `PhysicalDimensions.cs` as needed for new dimensions (e.g., force, energy).
    *   **Mathematical Relationships**: Implement relationships (e.g., F = m·a, P = F/A, E = F·d) as static methods or extension methods. Add unit tests to verify these relationships using both constants and calculated values.
    *   **Testing**: For each quantity: Create unit tests for creation, conversion, and validation. Add mathematical verification tests (e.g., compare calculated force to expected value). Add edge case and error handling tests.
    *   **Documentation**: Update or create: XML docs for all new types and members. Update `docs/complete-library-guide.md` with new mechanical quantities and usage examples. Update `README.md` and any references to examples (ensure they point to `docs/examples/`).
    *   **Integration and Performance**: Create tests that use both chemical and mechanical quantities together (e.g., energy calculations involving moles and force). Add benchmarks for common operations (unit conversions, arithmetic, etc.).
    *   **Review and Refactor**: As you implement, refactor any hard-coded values found in other domains to use the new constants. Ensure all code follows the standards (headers, null safety, XML docs, etc.).
    *   **Next Domains**: After Mechanical, move to Electromagnetic, then Thermal, then Optical, Acoustic, Nuclear, and Fluid Dynamics, following the same process.
*   When a file is missing the standard header, add the following to the top of the file:
```csharp
// Copyright (c) KTSU. All rights reserved.
```
*   `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
*   `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.
*   **Implementation Process for All Domains:**
    1.  For each quantity listed in the tracker:
        *   Check if the file exists and review its implementation.
        *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
        *   If compliant, mark as implemented in the tracker.
        *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Systematic Review and Update Process for All Domains:**
    1.  **For Each Domain (Mechanical, Electrical, Thermal, etc.):**
        *   For each quantity listed in the tracker:
            *   Check if the file exists and review its implementation.
            *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
            *   If compliant, mark as implemented in the tracker.
            *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Implementation Summary**
    *   **COMPLETED DOMAINS:**
        1.  **Chemical** (10/10 quantities)
        2.  **Mechanical** (15/15 quantities)
        3.  **Electrical** (11/11 quantities)
        4.  **Thermal** (10/10 quantities)
        5.  **Acoustic** (20/20 quantities)
        6.  **Nuclear** (5/5 quantities)
        7.  **Optical** (6/6 quantities)
        8.  **Fluid Dynamics** (5+ quantities)
    *   **REMAINING DOMAINS:**
        *   None

## CODING STANDARDS

(General coding standards and best practices are defined here.)

*   One type definition per file.
*   When using classes like `Path`, `File`, and `Directory` from `System.IO`, fully qualify the class name (e.g., `System.IO.Path`) if a `using System.IO;` statement is not present in the file.
*   When referencing methods or classes in XML documentation comments, use fully qualified names (e.g., `<see cref="System.IO.Path.IsPathFullyQualified(string)"/>`) to avoid ambiguous references.
*   Apply SOLID and DRY principles to improve code design.
*   When encountering CS0101 errors (namespace already contains a definition), and the definitions have different validation logic, rename one of the classes to avoid the conflict. Update all references to the renamed class.
*   When creating a type hierarchy, define interfaces for each level of abstraction to enable polymorphism. This includes base interfaces (e.g., `IPath`), category interfaces (e.g., `IAbsolutePath`, `IRelativePath`, `IFilePath`, `IDirectoryPath`), and composite interfaces (e.g., `IAbsoluteFilePath`, `IRelativeFilePath`, `IAbsoluteDirectoryPath`, `IRelativeDirectoryPath`). Implement these interfaces in the corresponding concrete classes.
*   All directory paths should have a public property called `Contents` that gets the files and directories in that directory as the appropriate semantic path types.
*   When using interface types in string operations (e.g., with `System.IO.Path` methods or string concatenation), cast the interface to its concrete type and call the `ToString()` method explicitly. For example: `Path.Combine(((DirectoryPath)directoryPath).ToString(), ((FileName)fileName).ToString())`.
*   When concatenating a string with the result of `ToString()` on a semantic type, use null protection to avoid potential null reference exceptions. For example: `"prefix_" + (path.ToString() ?? string.Empty)`.
*   Semantic paths support file system existence checking properties: `Exists` (true if the path exists as either a file or directory), `IsDirectory` (true if the path exists as a directory), and `IsFile` (true if the path exists as a file.
*   Semantic paths support implicit conversion to system strings, allowing them to be transparently passed in place of string parameters.
*   Semantic strings support implicit conversion to `string`, `char[]`, and `ReadOnlySpan<char>`.
*   When using interface types for semantic paths (e.g., `IAbsolutePath`, `IFilePath`), the implicit string conversion does not work. In these cases, you must either:
    *   Cast the interface to its concrete type and call `ToString()`.
    *   Call `ToString()` explicitly on the interface type.
*   Implement the `/` operator for all the semantic path types where it makes sense, and make it return the correct type. The operator should allow combining directory paths with relative paths to create new paths. Consider the following combinations:
    1.  `AbsoluteDirectoryPath` + `RelativeDirectoryPath` → `AbsoluteDirectoryPath`
    2.  `AbsoluteDirectoryPath` + `RelativeFilePath` → `AbsoluteFilePath`
    3.  `RelativeDirectoryPath` + `RelativeDirectoryDirectoryPath` → `RelativeDirectoryDirectoryPath`
    4.  `RelativeDirectoryPath` + `RelativeFilePath` → `RelativeFilePath`
    5.  Similar combinations for the base `DirectoryPath` types
*   When the linter complains about missing `Divide` methods, don't add them. Instead, silence the error with a `SuppressMessage` attribute. The `SuppressMessage` attribute should use the following justification: `"Path combination is the semantic meaning, not mathematical division"`.
*   Add methods to the semantic path types to get filename, file extension, directory etc from the appropriate types.
*   For `AbsoluteFilePath` and `RelativeFilePath`, add a property that returns the directory portion of the path as the correctly typed directory path (`AbsoluteDirectoryPath` or `RelativeDirectoryDirectoryPath`, respectively). This property should be named after the return type:
    *   `AbsoluteFilePath.AbsoluteDirectoryPath`
    *   `RelativeFilePath.RelativeDirectoryPath`
*   For `DirectoryPath`, `AbsoluteDirectoryPath`, and `RelativeDirectoryPath`, add the following properties:
    *   `Parent`: Gets the parent directory of this directory path as the correct semantic type.
    *   `Name`: Gets the name of this directory (the last component of the path) as a `FileName`.
*   For `AbsoluteFilePath` and `RelativeFilePath`:
    *   `FileNameWithoutExtension` - Gets just the filename without extension
    *   `ChangeExtension(FileExtension)` - Changes the file extension
    *   `RemoveExtension()` - Removes the file extension
    *   `IsChildOf(AbsoluteDirectoryPath)` - Checks if the file is within a directory
    *   `AbsoluteDirectoryPath` - Gets the directory as `AbsoluteDirectoryPath`.
*   For `RelativeFilePath`:
    *   `ToAbsolute(AbsoluteDirectoryPath)` - Converts relative to absolute path
    *   `RelativeDirectoryPath` - Gets the directory as `RelativeDirectoryPath`.
*   For `AbsoluteDirectoryPath`:
    *   `IsParentOf(AbsoluteFilePath/AbsoluteDirectoryPath)` - Checks parent-child relationships
    *   `IsChildOf(AbsoluteDirectoryPath)` - Checks if this is a child of another directory
    *   `Depth` - Gets the depth from root (0 for root directories)
    *   `GetAncestors()` - Gets all parent directories up to root
    *   `IsRoot` - Determines if this is a root directory
    *   `GetRelativePathTo(AbsoluteDirectoryPath)` - Creates relative path to another directory
*   For `RelativeDirectoryPath`:
    *   `Parent` - Gets the parent directory (appropriately typed)
    *   `Name` - Gets the directory name
    *   `Depth` - Gets the relative depth (number of directory levels)
    *   `ToAbsolute(AbsoluteDirectoryPath)` - Converts to absolute path using a base
    *   `Normalize()` - Normalizes the path by resolving `.` and `..` components
*   For the path hierarchy interfaces:
    *   `AsAbsoluteFilePath()` - Converts to `AbsoluteFilePath`
    *   `AsRelativeFilePath()` - Converts to `RelativeFilePath`
    *   `AsAbsoluteDirectoryPath()` - Converts to `AbsoluteDirectoryPath`
    *   `AsRelativeDirectoryPath()` - Converts to `RelativeDirectoryPath`
*   Consider caching expensive property computations such as `Path.GetDirectoryName` and `Path.GetFileNameWithoutExtension`. Use lazy initialization with the `??=` operator and private backing fields.
*   When implementing `IsChildOf` and `IsParentOf` methods:
    *   Cache full paths to avoid repeated `Path.GetFullPath` calls.
    *   Ensure the parent path ends with a directory separator for accurate comparison using `StartsWith`.
    *   Use `StringComparison.OrdinalIgnoreCase` for case-insensitive comparisons.
*   String Interning for Common Paths - Intern frequently used directory separators and common path roots
*   ReadOnlySpan\<char> Usage - Use spans for path parsing to reduce allocations
*   Pooled StringBuilder - For path combination operations
*   Async Directory Enumeration - For Contents property with large directories
*   Use span semantics instead of suffixing with "Span". Instead, use method overloading to provide span-based alternatives.
*   Use ReadOnlySpan overloads instead of creating methods with a Span suffix. If the signature overlaps with existing methods, the return type can be different.
*   When using implicit operators to convert to `ReadOnlySpan<char>`, use `value is null ? default : value.AsSpan()` instead of `value?.AsSpan() ?? default`.
*   When calculating directory `Depth`, the value is the number of directory separators in the path.
*   When implementing `IsChildOf` and `IsParentOf` methods:
    *   Cache full paths to avoid repeated `Path.GetFullPath` calls
    *   Ensure the parent path ends with a directory separator for accurate comparison using `StartsWith`.
    *   Use `StringComparison.OrdinalIgnoreCase` for case-insensitive comparisons.
*   For performance, replace `ToString()` calls with `WeakString` where appropriate.
*   For `IsChildOf()` and `IsParentOf()` methods, use span-based comparison for better performance than string concatenation. Normalize both paths before comparison to handle different separator styles.
*   When the signatures of existing methods overlap with span-based versions, use method overloading to provide span-based alternatives. If the signatures do not overlap, use different method names.
*   For the `Depth` property, the value is the number of directory separators in the path.
*   One type definition per file.
*   For ease of use, use a single common namespace for all types in the library.
*   SemanticStringValidationExamples can just be built in semantic types where appropriate
*   If the signatures of existing methods overlap with span-based versions, use method overloading to provide span-based alternatives. If the signatures do not overlap, use different method names.
*   The built in semantic string types should not need the string suffix.
*   For the implicit `ReadOnlySpan<char>` operator, use `value is null ? default : value.AsSpan()` instead of `value?.AsSpan() ?? default`.
*   When calculating directory `Depth`, the value is the number of directory separators in the path.
*   The built in semantic string types are either too niche or too simple, create a collection of useful builtin semantic string types with appropriate validations, where they aren't already implemented in dotnet, like Uri is.
*   Validation attributes should be separated into their own files.
*   Instead of creating generic built-in types like `Base64String`, use validation attributes like `[IsBase64]`, `[IsGuid]`, `[IsEmailAddress]` etc. that can be applied to domain-specific semantic string types. This is much more flexible and composable.
*   Validation attributes for different string casing types should be created, including title, pascal, kebab, snake, camel, macro, upper, lower, and sentence casing. These should be placed in a dedicated subdirectory for casing-related attributes: `Semantics/Validation/Attributes/Casing/`.
*   These are excellent advanced performance optimization suggestions:
    *   String Interning for Common Paths - Intern frequently used directory separators and common path roots
    *   ReadOnlySpan\<char> Usage - Use spans for path parsing to reduce allocations
    *   Pooled StringBuilder - For path combination operations
    *   Async Directory Enumeration - For Contents property with large directories
*   If there is already a first class type in .NET (e.g. `IPAddress`, `Version`, `Guid`), then the validator should direct users to use the first class type instead.
*   Validators that represent types that have first-class representations in dotnet already should provide accurate validation, but be listed as obsolete, prompting users to use the first class types.
*   Validators that represent types that have first-class representations in dotnet already should provide accurate validation, but be listed as obsolete, prompting users to use the first class types.
    *   `IsVersionAttribute` - Now marked as obsolete, encouraging users to use `System.Version` instead of semantic string types, highlighting the broader benefits
    *   `IsGuidAttribute` - Now marked as obsolete, encouraging users to use `System.Guid` instead of semantic string types, emphasizing type safety and efficiency
    *   `IsIpAddressAttribute` - Now suggests using `System.Net.IPAddress` instead of semantic string types, focusing on the comprehensive network API
    *   `IsDateTimeAttribute` - Now marked as obsolete, encouraging users to use `System.DateTime` instead of semantic string types, highlighting the broader benefits
    *   `IsTimeSpanAttribute` - Now marked as obsolete, encouraging users to use `System.TimeSpanAttribute` instead of semantic string types, highlighting the broader benefits
    *   `IsUriAttribute` - Now suggests using `System.Uri` instead of semantic string types, focusing on the comprehensive network API
    *   `IsDecimalAttribute` - Now suggests using `System.DecimalAttribute` instead of semantic string types, focusing on the comprehensive mathematical API
    *   `IsDoubleAttribute` - Now suggests using `System.DoubleAttribute` instead of semantic string types, focusing on the comprehensive mathematical API
    *   `IsInt32Attribute` - Now suggests using `System.Int32Attribute` instead of semantic string types, focusing on the comprehensive numerical API
    *   `IsBooleanAttribute` - Now suggests using `System.BooleanAttribute` instead of semantic string types, focusing on the comprehensive logical API
*   Use the FluentValidation library to implement the internals of the validation attributes where possible.
*   Provide feature parity between direct static methods and factory methods so users can choose their preferred pattern without losing functionality.
*   Use overloading with a more communicative common name for `From` and `TryFrom` methods instead of specifically type named variants.
*   When migrating the physical quantity functionality into the semantics library:
    *   The PhysicalQuantity library has:
        *   31+ physical quantity types (Length, Mass, Time, Energy, Velocity, etc.)
        *   A sophisticated base class `PhysicalQuantity<TSelf>` that extends `SemanticQuantity<TSelf, StorageType>`
        *   SI unit attributes for metadata (symbol, singular/plural names)
        *   Extension methods for unit conversions
        *   Integral and derivative operator interfaces for physical relationships
        *   Comprehensive conversion constants
    *   Create an attribute to define the SI unit for a class.
    *   Define an interface for integral operations between physical quantities.
    *   Define an interface for derivative operations between physical quantities.
    *   Provide conversion factors for various physical quantities and metric prefixes.
    *   Represent a physical quantity with a specific unit of measurement.
    *   Provide static methods for converting values to and from physical quantities.
*   When defining properties in `PhysicalQuantity` classes that override base class properties, ensure the types match exactly. For example, `Acceleration.Dimension` should be of type `PhysicalDimension` to match the overridden member `PhysicalQuantity<Acceleration, double>.Dimension`.
*   When defining `PhysicalQuantity` classes:
    *   Ensure the class is non-abstract and has a public parameterless constructor.
    *   Include XML documentation comments for all constructs.
    *   Avoid throwing exceptions from methods not expected to throw them.
    *   Ensure the base class `PhysicalQuantity<TSelf>` has a constructor that takes the required arguments.
    *   Ensure that all required methods and properties (e.g., `ConvertToUnit`, `Unit`) are defined or accessible in the current context.
    *   Ensure that all reference arguments are non-null by using `ArgumentNullException.ThrowIfNull()` if necessary.
*   When defining `PhysicalQuantity` classes, the correct pattern is:
    ```csharp
    public override PhysicalDimension Dimension => PhysicalDimensions.SomeDimension;
    public ClassName() : base() { }
    // Uses inherited Create(double value) method automatically
    ```
*   `PhysicalDimensionExtensions.cs` extensions should be to the `INumber` interface, rather than to all of the concrete types.
*   When creating extension methods for Physical Quantities:
    *   Use generic `INumber<T>` extensions instead of concrete type overloads. This will make the code more maintainable and work with all numeric types.
    *   Use `T.CreateChecked()` for conversion factors instead of hardcoded doubles
    *   Maintain original conversion logic and factors.
    *   Add proper XML documentation with `<typeparam>` tags.
    *   For PhysicalQuantity extension methods that use units, and thus the `Create(value, Units.SomeUnit)` syntax, remove the methods entirely.
    *   Eliminate backward compatibility methods that duplicate functionality.
*   When integrating the unit classes with `PhysicalDimensionExtensions`, conversion factors should be defined only once in the `Units` class. All conversions should use the same authoritative source, ensuring consistency and maintainability. This eliminates duplication and enables extensibility and type safety.
*   Eliminate the code that implements concrete storage types for quantities and only support the generics. Non-generic overloads can be added later where appropriate.
*   `PhysicalQuantity` represents an actual measured value:
    *   It combines a numerical value with dimensional information
    *   It provides the behavior for quantities (comparison, arithmetic, unit conversion)
    *   It's an abstract base class that specific quantities inherit from
    *   It includes business logic like `IsPhysicallyValid`, `In()` method for conversions, etc.
*   `PhysicalDimension` represents the dimensional analysis aspect:
    *   It's a mathematical concept that describes what type of measurement something is
    *   It stores the powers of the 7 fundamental SI base units (length, mass, time, etc.)
    *   It enables dimensional analysis (e.g., Force = M L² T⁻²)
    *   It's used for compile-time safety and unit conversion validation
    *   It's a struct that's immutable and lightweight
*   The relationship between `PhysicalQuantity` and `PhysicalDimension` is compositional, not identical: `PhysicalQuantity` **HAS-A** `PhysicalDimension`, it **IS-NOT-A** `PhysicalDimension`. This is a classic composition relationship where the quantity uses the dimension for validation and type safety.
*   Do not merge `PhysicalQuantity` and `PhysicalDimension`. Keeping them separate is beneficial because:
    1.  Single Responsibility: `PhysicalDimension` handles dimensional math, `PhysicalQuantity` handles value storage and behavior
    2.  Reusability: Multiple quantity types can share the same dimension (e.g., Energy and Torque both have dimension M L² T⁻²)
    3.  Performance: `PhysicalDimension` is a lightweight struct optimized for dimensional calculations
    4.  Type Safety: The current design provides excellent compile-time checking
    5.  Clarity: The separation makes the code's intent much clearer
*   `BaseUnit` is a property of the dimension, not the quantity.
*   For any given dimension, there's exactly one SI base unit.
*   It's repetitive and error-prone for every quantity class to have to manually specify the same BaseUnit for the same dimension.
*   The dimension should know its own base unit:
    ```csharp
    // In PhysicalDimension
    public IUnit BaseUnit => GetBaseUnitForDimension(this);

    // Or stored as static lookup
    public static IUnit GetBaseUnit(PhysicalDimension dimension) => dimension switch
    {
        var d when d == PhysicalDimensions.Force => Units.Newton,
        var d when d == PhysicalDimensions.Energy => Units.Joule,
        var d when d == PhysicalDimensions.Length => Units.Meter,
        // etc...
    };
    ```
*   Unit validation logic could be a method on `PhysicalDimension`:
    ```csharp
    // In PhysicalDimension
    public bool IsCompatibleWith(IUnit unit) => this.Equals(unit.Dimension);
    public void ValidateUnitCompatibility(IUnit unit) => /* validation logic */
    ```
*   The following should stay in `PhysicalQuantity`:
    *   Value storage and retrieval
    *   Arithmetic operations
    *   Comparison logic
    *   `IsPhysicallyValid` (this is about the specific value, not the dimension)
    *   `In()` conversion method (this operates on the value using dimensional info)
*   When refactoring `PhysicalQuantity` and `PhysicalDimension`:
    1.  Pass the base unit directly to the `PhysicalDimension` constructor.
    2.  Remove the `BaseUnit` property from `PhysicalQuantity` and its interface.
    3.  Update `PhysicalQuantity.In()` to use `Dimension.BaseUnit`.
*   When implementing PhysicalQuantity classes, ensure the containing type is one of the parameters in the generic type definition.
*   When creating new quantities, implement the following:
    *   Add any necessary dimensions to `PhysicalDimensions.cs`.
    *   Add any new units to `Units.cs`.
    *   Follow the existing code style and patterns.
    *   Include XML documentation comments.
    *   Implement mathematical relationships between related quantities.
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines.
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)
*   When a file is missing the standard header, add the following to the top of the file:
```csharp
// Copyright (c) KTSU. All rights reserved.
```
*   `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
*   `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.
*   **Implementation Process for All Domains:**
    1.  For each quantity listed in the tracker:
        *   Check if the file exists and review its implementation.
        *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
        *   If compliant, mark as implemented in the tracker.
        *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Systematic Review and Update Process for All Domains:**
    1.  **For Each Domain (Mechanical, Electrical, Thermal, etc.):**
        *   For each quantity listed in the tracker:
            *   Check if the file exists and review its implementation.
            *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
            *   If compliant, mark as implemented in the tracker.
            *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Implementation Summary**
    *   **COMPLETED DOMAINS:**
        1.  **Chemical** (10/10 quantities)
        2.  **Mechanical** (15/15 quantities)
        3.  **Electrical** (11/11 quantities)
        4.  **Thermal** (10/10 quantities)
        5.  **Acoustic** (20/20 quantities)
        6.  **Nuclear** (5/5 quantities)
        7.  **Optical** (6/6 quantities)
        8.  **Fluid Dynamics** (5+ quantities)
    *   **REMAINING DOMAINS:**
        *   None

## DEBUGGING

(Rules and guidelines for debugging are listed here.)

*   When encountering build errors, especially syntax errors reported by the compiler (e.g., CS1519, CS8124, CS1026, CS1002, CS1022), carefully examine the indicated line and surrounding code for typos, missing parentheses, semicolons, or other syntax violations.
*   When encountering CS0101 errors (namespace already contains a definition) or CS0579 errors (duplicate attribute), carefully check the indicated file for duplicate class definitions or attribute declarations.
*   If a test expects functionality that is not yet implemented, comment out or fix the test cases to align with the current implementation.
*   When resolving CS0029 errors (cannot implicitly convert type), carefully check if the type conversion is intended and whether the target type provides an implicit conversion operator. If not, explicitly access the intended property (e.g., `.Quantity`) or modify the test case accordingly.
*   When resolving CS7036 errors (no argument given that corresponds to the required parameter), ensure that all required parameters are provided in the method call. If the parameter is optional, consider providing a default value.
*   When resolving CS0019 errors (operator cannot be applied to operands of type), ensure that the operands support the specified operator. If not, explicitly access the intended property or modify the test case accordingly.
*   When debugging `IndexOfAny` or `LastIndexOfAny` methods in `SemanticStringTests`, verify that the expected index in the test case aligns with the actual index returned by the standard .NET string methods. Incorrect test expectations can lead to false positives. If the test expectation is incorrect, correct the test case to align with the actual index returned by the .NET string methods.
*   When debugging `FormatException` errors within `SemanticString<TDest>.PerformValidation` during validation strategy testing (e.g., `LongString_WithValidations_HandledCorrectly`), ensure that the input string being converted to the target type `TDest` adheres to the expected format and constraints defined by the validation logic. Pay close attention to string length, prefixes, and suffixes as defined in the validation.
    *   Specifically, when a `SemanticString<TDest>` is decorated with a `PrefixAndSuffixAttribute`, ensure that test cases use the correct prefix and suffix as defined in the attribute. A mismatch between the expected prefix/suffix in the attribute and the actual prefix/suffix in the test string will cause a `FormatException` during validation.
*   When debugging `IsPathAttribute_PathWithInvalidChars_ShouldFail` tests, be aware that `.NET` versions after `.NET Framework` may return a reduced set of invalid characters from `Path.GetInvalidPathChars()`. If the test expects characters like `<` and `>` to be invalid, ensure that the `IsPathAttribute` validation logic
*   When encountering analyzer warnings