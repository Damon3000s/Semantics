---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new user–AI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

*   FluentValidation

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.
*   Put examples in documents, not in code.
*   **Ensure the documentation is correct.**
*   The primary problem is that the **README.md file refers to an `examples/` directory at the root level, but the examples are actually located in `docs/examples/`**. All references in `README.md` to the `examples/` directory should be updated to `docs/examples/`.
*   The architecture documentation should accurately reflect the actual class hierarchy implementation.
*   The validation reference documentation should be comprehensive and accurate, including newer validation attributes.
*   Update the `README.md` and `docs/` to describe the whole library.
*   Create a `docs/complete-library-guide.md` file to provide a comprehensive overview of all features and components in the ktsu.Semantics library.
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines.
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.
*   Remove all of the example documentation from the XML comments.
*   **Domain Implementation Workflow**
    1.  Use the Chemical domain as a template.
    2.  Before coding, search for any hard-coded constants and add them to `PhysicalConstants.cs`.
    3.  Implement quantities with full unit conversions and dimensional analysis.
    4.  Add comprehensive unit tests, including mathematical relationship checks.
    5.  Document all new quantities and constants.
*   **Always centralize physical constants** in `PhysicalConstants.cs` before using them in any domain.
*   **Use type-safe generic accessors** for all constants.
*   **Refactor any hard-coded values** found in new or existing code.
*   **Document all sources** for constants (CODATA, NIST, ISO/IEC).
*   **Follow the established code and documentation standards** (file headers, XML docs, null safety, generic constraints).
*   **Test thoroughly**: unit tests, mathematical verification, integration tests.
*   **Mechanical Domain Implementation (Highest Priority)**
    *   Implement quantities like Force, Energy, Power, Pressure, etc., with full unit conversions and dimensional analysis.
    *   Add comprehensive unit tests, including mathematical relationship checks (e.g., F = m·a, P = F/A, E = F·d).
    *   Document all new quantities and constants.
*   **Integration Tests**
    *   Create tests that use quantities from multiple domains in calculations.
    *   Verify that units and conversions work seamlessly across domains.
*   **Performance Benchmarks**
    *   Add benchmarks for common operations (e.g., unit conversions, arithmetic).
    *   Optimize as needed.
*   **Documentation Expansion**
    *   Update the `docs/complete-library-guide.md` with new domains and features.
    *   Add usage examples for new quantities.
    *   Ensure all references in `README.md` and other docs are accurate (e.g., `docs/examples/`).
*   **Implementation Plan and Tracker**
    *   **Physical Constants First**: Identify all mechanical constants needed (e.g., gravitational acceleration, standard atmospheric pressure, Planck’s constant if needed for mechanics, etc.). Add them to `PhysicalConstants.cs` under appropriate categories (Fundamental, Mechanical, etc.). Use the `PhysicalConstants.Generic` pattern for type-safe access. Include XML docs and source references (CODATA, NIST, etc.).
    *   **Define Quantities**:
        *   Location: `Quantities/Mechanics/`
        *   Quantities to Implement: Force (`Force.cs`), Pressure (`Pressure.cs`), Energy (`Energy.cs`), Power (`Power.cs`), Torque (`Torque.cs`), Momentum (`Momentum.cs`), AngularVelocity (`AngularVelocity.cs`), AngularAcceleration (`AngularAcceleration.cs`), MomentOfInertia (`MomentOfInertia.cs`), Density (`Density.cs`), SpecificGravity (`SpecificGravity.cs`), and any others listed in your TODOs. Follow the template from the Chemical domain (generic, type-safe, XML docs, unit conversions, etc.).
    *   **Units and Dimensions**: For each quantity, define the SI and common units in `Units.cs`. Add or update `PhysicalDimensions.cs` as needed for new dimensions (e.g., force, energy).
    *   **Mathematical Relationships**: Implement relationships (e.g., F = m·a, P = F/A, E = F·d) as static methods or extension methods. Add unit tests to verify these relationships using both constants and calculated values.
    *   **Testing**: For each quantity: Create unit tests for creation, conversion, and validation. Add mathematical verification tests (e.g., compare calculated force to expected value). Add edge case and error handling tests.
    *   **Documentation**: Update or create: XML docs for all new types and members. Update `docs/complete-library-guide.md` with new mechanical quantities and usage examples. Update `README.md` and any references to examples (ensure they point to `docs/examples/`).
    *   **Integration and Performance**: Create tests that use both chemical and mechanical quantities together (e.g., energy calculations involving moles and force). Add benchmarks for common operations (unit conversions, arithmetic, etc.).
    *   **Review and Refactor**: As you implement, refactor any hard-coded values found in other domains to use the new constants. Ensure all code follows the standards (headers, null safety, XML docs, etc.).
    *   **Next Domains**: After Mechanical, move to Electromagnetic, then Thermal, then Optical, Acoustic, Nuclear, and Fluid Dynamics, following the same process.
*   When a file is missing the standard header, add the following to the top of the file:
```csharp
// Copyright (c) KTSU. All rights reserved.
```
*   `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
*   `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.
*   **Implementation Process for All Domains:**
    1.  For each quantity listed in the tracker:
        *   Check if the file exists and review its implementation.
        *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
        *   If compliant, mark as implemented in the tracker.
        *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Systematic Review and Update Process for All Domains:**
    1.  **For Each Domain (Mechanical, Electrical, Thermal, etc.):**
        *   For each quantity listed in the tracker:
            *   Check if the file exists and review its implementation.
            *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
            *   If compliant, mark as implemented in the tracker.
            *   If not, note what’s missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Implementation Summary**
    *   **COMPLETED DOMAINS:**
        1.  **Chemical** (10/10 quantities)
        2.  **Mechanical** (15/15 quantities)
        3.  **Electrical** (11/11 quantities)
        4.  **Thermal** (10/10 quantities)
        5.  **Acoustic** (20/20 quantities)
        6.  **Nuclear** (5/5 quantities)
        7.  **Optical** (6/6 quantities)
        8.  **Fluid Dynamics** (5/5 quantities)
    *   **REMAINING DOMAINS:**
        *   None
*   Missing friendly method alternates are not required for operators that define integral/derivative relationships, they can be suppressed with an attribute using:
```csharp
[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]
```
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation, until the formula depends on a culculation thats not in an SI base unit.
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation. Even further than that, you can use the multiply and divide operators on the PhysicalQuantity derived types directly.
*   When implementing physics relationships:
    *   Use the `.Value` property directly instead of performing unit conversions.
    *   Suppress CA2225 warnings using `[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]`.
    *   The dimensional analysis infrastructure exists in `PhysicalDimension` and base classes, but the specific physics relationships need systematic implementation across all quantity types.
    *   The current implementation lacks the fundamental integration and derivative relationships that should be expressed through `*` and `/` operators.
*   When `Force * Length` could be interpreted as energy or torque, making these calls ambiguous with the same parameters but a different return type:
    *   Keep the more fundamental relationship (work/energy) as an operator.
    *   Use an explicit method for torque.
*   When a test fails update it to use the new operator syntax instead of the removed `FromForceAndArea` method.
*   When creating PhysicalDimensions:
    *   Replace all `Units.` references in `PhysicalDimensions.cs` with the corresponding `Bootstrap` units.
*   When working with dimensionless quantities:
    *   Reserve Radians for Angular Quantities Only
    *   Create Semantically Appropriate Dimensionless Units. For example, use BootstrapDimensionless, BootstrapDecibel and BootstrapPH for non-angular dimensionless quantities.